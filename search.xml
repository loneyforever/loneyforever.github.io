<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/04/21/hello-world/"/>
      <url>/2024/04/21/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>字符串哈希</title>
      <link href="/2023/05/08/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/"/>
      <url>/2023/05/08/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="一、理解"><a href="#一、理解" class="headerlink" title="一、理解"></a>一、理解</h3><p><strong>字符串哈希算法，实质就是将一个字符串转化成一个数字来简化比较过程。当一个字符串规模很大，并且需要多次访问该字符串或者子串的时候，我们可以用哈希函数对每个子串进程哈希映射，分别映射到不同的数字中去，即一个子串对应一个哈希值，也可以通过哈希值快速找到子串。</strong></p><p>字符串哈希算法的关键是哈希函数，这里我们使用BKDR哈希函数。实质就是将一个字符串转化成一个P进制的数。</p><p><strong>原理：设定一个进制P，当需要计算一个字符串的哈希值是，把字符串的每个字符看作是每个进制位上的一个数字，这个串转化成了一个基于进制P的数，最后再取余数就得到了这个字符串的哈希值。（为了简化计算可以区空间大小位 $M&#x3D;2^{64}$ 是unsigned long long 的长度，一个unsigned long long 型的哈希值H，当H的值大于M时，会自动溢出，即自动对M取余，这样可以避免低效的区域运算）</strong></p><h4 id="（1）常用的进制："><a href="#（1）常用的进制：" class="headerlink" title="（1）常用的进制："></a>（1）常用的进制：</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">131、13331、13131、131313等，这些数值能够有效避免碰撞。</span><br></pre></td></tr></table></figure><h4 id="（2）具体思路"><a href="#（2）具体思路" class="headerlink" title="（2）具体思路"></a>（2）具体思路</h4><p>首先，先对字符串的全部前缀进行哈希值的计算（这里需要用的前缀和的知识，<a href="https://jiangwenxin.com.cn/2023/04/04/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/">前缀和传送门</a>），这样我们提前求出了每个字符的哈希值了，这时候我们求子串的哈希值（即子区间）就变得容易了。例如我现在要求区间 $[i, j]$ 的哈希值，就是 $区间[0, j] 的哈希值 - (区间[0,i]的哈希值 × p[j-i+1]) $ 的值。</p><h3 id="二、具体实现（可当作模板使用）"><a href="#二、具体实现（可当作模板使用）" class="headerlink" title="二、具体实现（可当作模板使用）"></a>二、具体实现（可当作模板使用）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"></span><br><span class="line">ull base = <span class="number">131</span>;<span class="comment">// 常用的值有131，13331等，能够有效避免碰撞</span></span><br><span class="line">vector&lt;ull&gt; h, p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getHash</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">h.<span class="built_in">resize</span>(len + <span class="number">1</span>), p.<span class="built_in">resize</span>(len + <span class="number">1</span>);</span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">h[i] = h[i - <span class="number">1</span>] * base + s[i];</span><br><span class="line">p[i] = p[i - <span class="number">1</span>] * base;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ull <span class="title">get_w</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、例题"><a href="#三、例题" class="headerlink" title="三、例题"></a>三、例题</h3><h4 id="Acwing-841-字符串哈希。"><a href="#Acwing-841-字符串哈希。" class="headerlink" title="Acwing.841.字符串哈希。"></a>Acwing.841.字符串哈希。</h4><p>给定一个长度为n的字符串，再给定m个询问，每个询问包含四个整数l1,r1,l2,r2，请你判断[l1,r1]和[l2,r2]这两个区间所包含的字符串子串是否完全相同。（字符串中只包含大小写英文字母和数字。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数n和m，表示字符串长度和询问次数。</p><p>第二行包含一个长度为n的字符串，字符串只包含大小写英文字母和数字。</p><p>接下来m行，每行包含四个整数l1,r1,l2,r2，表示一次询问所涉及的两个区间。</p><p>注意字符串的位置从1开始编号。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每个询问输出一个结果，如果两个字符串子串完全相同则输出<code>Yes</code>，否则输出<code>No</code>。</p><p>每个结果占一行。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1≤n,m≤10^5$</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">8 3</span><br><span class="line">aabbaabb</span><br><span class="line">1 3 5 7</span><br><span class="line">1 3 6 8</span><br><span class="line">1 2 1 2</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"></span><br><span class="line">ull base = <span class="number">131</span>;<span class="comment">// 常用的值有131，13331等，能够有效避免碰撞</span></span><br><span class="line">vector&lt;ull&gt; h, p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getHash</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">h.<span class="built_in">resize</span>(len + <span class="number">1</span>), p.<span class="built_in">resize</span>(len + <span class="number">1</span>);</span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">h[i] = h[i - <span class="number">1</span>] * base + s[i];</span><br><span class="line">p[i] = p[i - <span class="number">1</span>] * base;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ull <span class="title">get_w</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">string s;</span><br><span class="line">cin &gt;&gt; s;</span><br><span class="line"><span class="built_in">getHash</span>(s);</span><br><span class="line"><span class="keyword">while</span> (m--) &#123;</span><br><span class="line"><span class="type">int</span> l1, r1, l2, r2;</span><br><span class="line">cin &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">get_w</span>(l1, r1) == <span class="built_in">get_w</span>(l2, r2)) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速幂</title>
      <link href="/2023/05/07/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
      <url>/2023/05/07/%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
      
        <content type="html"><![CDATA[<h3 id="一、快速幂"><a href="#一、快速幂" class="headerlink" title="一、快速幂"></a>一、快速幂</h3><h4 id="（1）概念"><a href="#（1）概念" class="headerlink" title="（1）概念"></a>（1）概念</h4><p>快速幂是一种快速求一个数的幂次方的方法。比如 $a^n$ 。当然也有暴力的方法，那就是 $n$ 个 $a$ 相乘，时间复杂度为 $O(n)$ 时间复杂度较高，很多时候都会超时。但是快速幂大大的降低了时间复杂度。主要利用了分治的思想，即先算 $a^2$ ，然后继续算 $(a^2)^2$ ，一直算到  $n$ 次幂，时间复杂度为 $O(log_2n)$ 。</p><h4 id="（2）具体过程理解（以-a-11-为例，使用位运算举例）"><a href="#（2）具体过程理解（以-a-11-为例，使用位运算举例）" class="headerlink" title="（2）具体过程理解（以 $a^{11}$ 为例，使用位运算举例）"></a>（2）具体过程理解（以 $a^{11}$ 为例，使用位运算举例）</h4><table><thead><tr><th align="center"></th><th align="center">n</th><th align="center">res(res *&#x3D;  base)</th><th align="center">base(base *&#x3D; base)</th></tr></thead><tbody><tr><td align="center">第一轮</td><td align="center">1011</td><td align="center">$a^1$</td><td align="center">$a^2$</td></tr><tr><td align="center">第二轮</td><td align="center">101</td><td align="center">$a^1 × a^2$</td><td align="center">$a^4$</td></tr><tr><td align="center">第三轮</td><td align="center">10</td><td align="center">res不变</td><td align="center">$a^8$</td></tr><tr><td align="center">第四轮</td><td align="center">1</td><td align="center">$a^1×a^2×a^8$</td><td align="center">$a^{16}$</td></tr><tr><td align="center">结束</td><td align="center">0</td><td align="center"></td><td align="center"></td></tr></tbody></table><h4 id="（3）具体代码"><a href="#（3）具体代码" class="headerlink" title="（3）具体代码"></a>（3）具体代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fastPow</span><span class="params">(<span class="type">int</span> base, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (n) &#123;</span><br><span class="line"><span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">res *= base;</span><br><span class="line">&#125;</span><br><span class="line">base *= base;</span><br><span class="line">n &gt;&gt;= <span class="number">1</span>;<span class="comment">// 右移一位，在除以2的同时把末尾已经处理过的1去掉</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">fastPow</span>(<span class="number">2</span>, <span class="number">11</span>) &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、取模"><a href="#二、取模" class="headerlink" title="二、取模"></a>二、取模</h3><h4 id="取模运算的性质："><a href="#取模运算的性质：" class="headerlink" title="取模运算的性质："></a>取模运算的性质：</h4><p>加：$(a+b) ; mod ; m &#x3D; ((a ; mod ; m) + (b ; mod ; m));mod ; m$</p><p>减：$(a-b) ; mod ; m &#x3D; ((a ; mod ; m) - (b ; mod ; m));mod ; m$</p><p>乘：$(a×b) ; mod ; m &#x3D; ((a ; mod ; m) × (b ; mod ; m));mod ; m$</p><p><strong>对除法取模需要用到逆元，这里暂时不讲。</strong></p><h3 id="三、快速幂取模"><a href="#三、快速幂取模" class="headerlink" title="三、快速幂取模"></a>三、快速幂取模</h3><p>由于幂运算的结果往往都很打，会超出变量类型的最大值，甚至超过内存所能存放的最大数，所以涉及到快速幂的题目通常都会做取模操作，缩小结果。</p><p>根据模运算的性质，对 $a^n$ 取模和先对 $a$ 取模在做幂运算的结果是一样的。即：$a^n ; mod ; m&#x3D;(a; mod m)^n ; mod ;m$</p><h4 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = INT_MAX;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fastPow</span><span class="params">(<span class="type">int</span> base, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (n) &#123;</span><br><span class="line"><span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">res = (res * base) % mod;</span><br><span class="line">&#125;</span><br><span class="line">base = (base * base) % mod;</span><br><span class="line">n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cout &lt;&lt; <span class="built_in">fastPow</span>(<span class="number">2</span>, <span class="number">11</span>) &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、矩阵快速幂"><a href="#四、矩阵快速幂" class="headerlink" title="四、矩阵快速幂"></a>四、矩阵快速幂</h3><p>给定一个 $m; ×; m$ 的矩阵 $A$ ，求它的 $n$ 次幂 $A^n$ ，这也是很常见的计算。矩阵快速幂的原理是把矩阵当作变量来操作。</p><p><strong>首先需要定义矩阵的结构体，并且定义矩阵相乘的操作。同时矩阵相乘也需要取模。</strong></p><h4 id="具体代码实现："><a href="#具体代码实现：" class="headerlink" title="具体代码实现："></a>具体代码实现：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = INT_MAX;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">2</span>;<span class="comment">// 定义矩阵的阶，默认为2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span> &#123;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; m;</span><br><span class="line"><span class="built_in">Matrix</span>() &#123;<span class="comment">// 无参构造函数构造一个默认矩阵</span></span><br><span class="line">m.<span class="built_in">resize</span>(MAXN, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(MAXN));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Matrix</span>(<span class="type">int</span> n) &#123;<span class="comment">// 有参构造函数，根据参数构造矩阵</span></span><br><span class="line">m.<span class="built_in">resize</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">Multi</span><span class="params">(Matrix a, Matrix b)</span> </span>&#123;</span><br><span class="line">Matrix res;</span><br><span class="line"><span class="type">int</span> len = a.m.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; len; k++) &#123;</span><br><span class="line">res.m[i][j] = (res.m[i][j] + a.m[i][k] + b.m[k][j]) % mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">fastm</span><span class="params">(Matrix a, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> len = a.m.<span class="built_in">size</span>();</span><br><span class="line">Matrix res;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">res.m[i][i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (n) &#123;</span><br><span class="line"><span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">res = <span class="built_in">Multi</span>(res, a);</span><br><span class="line">&#125;</span><br><span class="line">a = <span class="built_in">Multi</span>(a, a);</span><br><span class="line">n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态分区分配算法</title>
      <link href="/2023/05/01/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95/"/>
      <url>/2023/05/01/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h3><p>​<strong>动态分区分配方式公有四种，分别是首次适应算法、循环首次适应算法、最佳适应算法、最坏适应算法。</strong></p><h4 id="（1）首次适应算法"><a href="#（1）首次适应算法" class="headerlink" title="（1）首次适应算法"></a>（1）首次适应算法</h4><p><strong>思路</strong>：每次都是从低地址开始查找，从找到的第一个能够满足大小的空闲分区中划分一片空间分配给申请者。如果查找完所有的空闲分区都没有一个能满足需求的分区，则分配失败。</p><p><strong>优点</strong>：优先利用低址部分的空闲分区，从而保留了高址部分的大空闲区，为大作业分配空间创造了条件。</p><p><strong>缺点</strong>：低址部分不断被划分，会留下许多难以利用的、很小的空闲分区，即碎片造成浪费。同时每次查找都是从低址开始，这无疑会增加查找过程中的时间开销。</p><h4 id="（2）循环首次适应算法"><a href="#（2）循环首次适应算法" class="headerlink" title="（2）循环首次适应算法"></a>（2）循环首次适应算法</h4><p><strong>思路</strong>：循环首次适应算法在为进程分配内存空间时，每次都是从上次找到的空闲分区的下一片空闲分区开始开始查找，直到找到一片能够满足要求的空闲分区，从中划分一片空间给请求者。如果查找到链尾还不满足，则返回到链首继续查找。如果查找到开始的节点还没有满足需求的空间，则分配失败。</p><p><strong>优点</strong>：能够时内存中的空闲分区分布得更均匀，从而减少查找时的时间开销。</p><p><strong>缺点</strong>：缺乏大的空闲分区。</p><h4 id="（3）最佳适应算法"><a href="#（3）最佳适应算法" class="headerlink" title="（3）最佳适应算法"></a>（3）最佳适应算法</h4><p><strong>思路</strong>：最佳适应算法每次在为作业分配内存时，总是把空闲分区按照从小大排序，然后从最小的空闲分区开始查找，直到找到满足需求的第一个分区，从中分配一片空间给请求者。</p><p><strong>优点</strong>：孤立的看是最佳的算法，因为第一次找到的能满足条件的空间是最佳的。</p><p><strong>缺点</strong>：因为其每次分割所留下来的部分总是最小的，这样就会留下许多难以利用的空间碎片。</p><h4 id="（4）最坏适应算法"><a href="#（4）最坏适应算法" class="headerlink" title="（4）最坏适应算法"></a>（4）最坏适应算法</h4><p><strong>思路</strong>：最坏适应算法与最佳适应算法则与最佳适应算法相反，每次从最大的空闲分区开始查找，从找到的第一个分区中分配一片空间给请求者。若是第一个空闲分区都无法满足要求则分配失败。</p><p><strong>优点</strong>：能够使剩下的空闲区不至于太小，产生碎片的可能性小，对中小作业有利。同时查找效率高。</p><p><strong>缺点</strong>：由于每次总是挑选最大的分区进行分割，导致最后缺乏大的空闲分区，导致大作业分配失败。</p><h4 id="（5）下面是动态分区的流程图"><a href="#（5）下面是动态分区的流程图" class="headerlink" title="（5）下面是动态分区的流程图"></a>（5）下面是动态分区的流程图</h4><p><img src="/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95/%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p><h4 id="（6）回收分区应考虑的以下三种情况"><a href="#（6）回收分区应考虑的以下三种情况" class="headerlink" title="（6）回收分区应考虑的以下三种情况"></a>（6）回收分区应考虑的以下三种情况</h4><ol><li>当待回收的分区的前一个分区（物理地址挨着）为空闲分区时，则应合并两个分区。</li><li>当待回收的分区的后一个分区为空闲分区时，则应合并两个分区。</li><li>当待回收的分区的前后两个分区都空闲时，则应合并三个分区。</li></ol><p><strong>如图所示：</strong></p><p><img src="/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%94%B6%E4%BB%8B%E7%BB%8D%E5%9B%BE.png" alt="回收介绍图"></p><h3 id="二、代码实现（此处只实现了首次适应和最佳适应算法，另外两个算法类似）"><a href="#二、代码实现（此处只实现了首次适应和最佳适应算法，另外两个算法类似）" class="headerlink" title="二、代码实现（此处只实现了首次适应和最佳适应算法，另外两个算法类似）"></a>二、代码实现（此处只实现了首次适应和最佳适应算法，另外两个算法类似）</h3><p><strong>解释</strong>：本程序使用了STL库中的list（<a href="https://jiangwenxin.com.cn/2023/04/16/C++%E9%93%BE%E8%A1%A8%E4%B8%8EList/">list传送门</a>）来存储，同时使用了多线程编程来模拟回收内存机制（即每次分配一片空间，就创建一个线程来执行回收操作，在每次回收时，利用随机数来让线程随眠相应时间，模拟进程运行过程）。在对共享资源进行操作时，使用了线程锁来保护共享资源同一时刻只能由当前线程来访问并修改。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">disk</span> &#123;</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="type">int</span> Size;</span><br><span class="line"><span class="type">int</span> start;</span><br><span class="line"><span class="type">int</span> status;</span><br><span class="line">&#125;dis;</span><br><span class="line"></span><br><span class="line">list&lt;dis&gt; L;<span class="comment">// 空间分配情况链表</span></span><br><span class="line"><span class="type">int</span> id_sta;<span class="comment">// 任务id</span></span><br><span class="line">mutex num_mutex;<span class="comment">// 声明线程互斥锁</span></span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>, fp = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Rand</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">rand</span>() % <span class="number">10</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;dis&gt; a&#123;</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1024</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">2048</span>, <span class="number">2000</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">4096</span>, <span class="number">4000</span>, <span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">L.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">&#125;</span><br><span class="line">id_sta = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; <span class="string">&quot;id&quot;</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="string">&quot;size&quot;</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="string">&quot;start&quot;</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="string">&quot;status&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : L) &#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; i.id &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; i.Size &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; i.start &lt;&lt; <span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; i.status &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(dis a, dis b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.start &lt; b.start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp2</span><span class="params">(dis a, dis b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.Size &lt; b.Size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">first_fit</span><span class="params">(<span class="type">int</span> Size)</span> </span>&#123;</span><br><span class="line">L.<span class="built_in">sort</span>(cmp1);</span><br><span class="line">num_mutex.<span class="built_in">lock</span>();<span class="comment">// 开启线程锁</span></span><br><span class="line"><span class="keyword">for</span> (list&lt;dis&gt;::iterator i = L.<span class="built_in">begin</span>(); i != L.<span class="built_in">end</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i-&gt;status == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (i-&gt;Size == Size) &#123;</span><br><span class="line">i-&gt;id = id_sta++;</span><br><span class="line">i-&gt;status = <span class="number">1</span>;</span><br><span class="line">num_mutex.<span class="built_in">unlock</span>();<span class="comment">// 关闭线程锁</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;分配成功！分配结果如下:&quot;</span> &lt;&lt; endl;</span><br><span class="line">L.<span class="built_in">sort</span>(cmp1);</span><br><span class="line"><span class="built_in">print</span>();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i-&gt;Size &gt; Size) &#123;</span><br><span class="line">dis node;</span><br><span class="line">node.id = id_sta++;</span><br><span class="line">node.Size = Size;</span><br><span class="line">node.start = i-&gt;start;</span><br><span class="line">node.status = <span class="number">1</span>;</span><br><span class="line">i-&gt;start += Size;</span><br><span class="line">i-&gt;Size -= Size;</span><br><span class="line">L.<span class="built_in">push_back</span>(node);</span><br><span class="line">num_mutex.<span class="built_in">unlock</span>();<span class="comment">// 关闭线程锁</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;分配成功！分配结果如下:&quot;</span> &lt;&lt; endl;</span><br><span class="line">L.<span class="built_in">sort</span>(cmp1);</span><br><span class="line"><span class="built_in">print</span>();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">num_mutex.<span class="built_in">unlock</span>();<span class="comment">// 关闭线程锁</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;空间分配失败&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">best_fit</span><span class="params">(<span class="type">int</span> Size)</span> </span>&#123;</span><br><span class="line">L.<span class="built_in">sort</span>(cmp2);</span><br><span class="line">num_mutex.<span class="built_in">lock</span>();<span class="comment">// 开启线程锁</span></span><br><span class="line"><span class="keyword">for</span> (list&lt;dis&gt;::iterator i = L.<span class="built_in">begin</span>(); i != L.<span class="built_in">end</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i-&gt;status == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (i-&gt;Size == Size) &#123;</span><br><span class="line">i-&gt;id = id_sta++;</span><br><span class="line">i-&gt;status = <span class="number">1</span>;</span><br><span class="line">num_mutex.<span class="built_in">unlock</span>();<span class="comment">// 关闭线程锁</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;分配成功！分配结果如下:&quot;</span> &lt;&lt; endl;</span><br><span class="line">L.<span class="built_in">sort</span>(cmp2);</span><br><span class="line"><span class="built_in">print</span>();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i-&gt;Size &gt; Size) &#123;</span><br><span class="line">dis node;</span><br><span class="line">node.id = id_sta++;</span><br><span class="line">node.Size = Size;</span><br><span class="line">node.start = i-&gt;start;</span><br><span class="line">node.status = <span class="number">1</span>;</span><br><span class="line">i-&gt;start += Size;</span><br><span class="line">i-&gt;Size -= Size;</span><br><span class="line">L.<span class="built_in">push_back</span>(node);</span><br><span class="line">num_mutex.<span class="built_in">unlock</span>();<span class="comment">// 关闭线程锁</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;分配成功！分配结果如下:&quot;</span> &lt;&lt; endl;</span><br><span class="line">L.<span class="built_in">sort</span>(cmp2);</span><br><span class="line"><span class="built_in">print</span>();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">num_mutex.<span class="built_in">unlock</span>();<span class="comment">// 关闭线程锁</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;空间分配失败&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Auto_release</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> Time = <span class="built_in">Rand</span>();</span><br><span class="line">this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(Time * <span class="number">1000</span>));</span><br><span class="line">L.<span class="built_in">sort</span>(cmp1);</span><br><span class="line">num_mutex.<span class="built_in">lock</span>();<span class="comment">// 开启线程锁</span></span><br><span class="line">list&lt;dis&gt;::iterator j = L.<span class="built_in">begin</span>(), k;</span><br><span class="line"><span class="keyword">for</span> (list&lt;dis&gt;::iterator i = L.<span class="built_in">begin</span>(); i != L.<span class="built_in">end</span>(); ) &#123;</span><br><span class="line"><span class="keyword">if</span> (i-&gt;id == id) &#123;</span><br><span class="line">k = ++i;</span><br><span class="line">i--;</span><br><span class="line"><span class="keyword">if</span> (i != L.<span class="built_in">begin</span>() &amp;&amp; j-&gt;status == <span class="number">0</span> &amp;&amp; k-&gt;status == <span class="number">0</span> &amp;&amp; j-&gt;start + j-&gt;Size == i-&gt;start &amp;&amp; k != L.<span class="built_in">end</span>() &amp;&amp; i-&gt;start + i-&gt;Size == k-&gt;start) &#123;</span><br><span class="line">j-&gt;Size += (i-&gt;Size + k-&gt;Size);</span><br><span class="line">j-&gt;id = <span class="number">0</span>;</span><br><span class="line">j-&gt;status = <span class="number">0</span>;</span><br><span class="line">k++;</span><br><span class="line"><span class="keyword">if</span> (k != L.<span class="built_in">end</span>()) &#123;</span><br><span class="line">i = L.<span class="built_in">erase</span>(i, ++k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">k = i++;</span><br><span class="line">k = L.<span class="built_in">erase</span>(k, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i != j &amp;&amp; j-&gt;status == <span class="number">0</span> &amp;&amp; j-&gt;start + j-&gt;Size == i-&gt;start) &#123;</span><br><span class="line">j-&gt;Size += i-&gt;Size;</span><br><span class="line">j-&gt;id = <span class="number">0</span>;</span><br><span class="line">j-&gt;status = <span class="number">0</span>;</span><br><span class="line">i = L.<span class="built_in">erase</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (k != L.<span class="built_in">end</span>() &amp;&amp; k-&gt;status == <span class="number">0</span> &amp;&amp; i-&gt;start + i-&gt;Size == k-&gt;start) &#123;</span><br><span class="line">i-&gt;Size += k-&gt;Size;</span><br><span class="line">i-&gt;id = <span class="number">0</span>;</span><br><span class="line">i-&gt;status = <span class="number">0</span>;</span><br><span class="line">k = L.<span class="built_in">erase</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">i = L.<span class="built_in">erase</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">j = i;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">num_mutex.<span class="built_in">unlock</span>();<span class="comment">// 关闭线程锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Menu</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> flag;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请选择分配空间方式（1.首次适应算法   2.最优适应算法3.退出）&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; flag;</span><br><span class="line"><span class="keyword">if</span> (flag != <span class="number">1</span> &amp;&amp; flag != <span class="number">2</span> &amp;&amp; flag != <span class="number">3</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;选择错误，请重新选择&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag == <span class="number">3</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">L.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">Init</span>();</span><br><span class="line"><span class="built_in">print</span>();</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="type">int</span> Size;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入作业的大小&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; Size;</span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="function">thread <span class="title">a</span><span class="params">(first_fit, Size)</span></span>;</span><br><span class="line">a.<span class="built_in">join</span>();</span><br><span class="line"><span class="function">thread <span class="title">b</span><span class="params">(Auto_release, id_sta - <span class="number">1</span>)</span></span>;</span><br><span class="line">b.<span class="built_in">detach</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">thread <span class="built_in">a</span>(best_fit, Size);</span><br><span class="line">a.<span class="built_in">join</span>();</span><br><span class="line"><span class="function">thread <span class="title">b</span><span class="params">(Auto_release, id_sta - <span class="number">1</span>)</span></span>;</span><br><span class="line">b.<span class="built_in">detach</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;是否继续分配空间:（按Y/y继续分配）&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; c;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">&#x27;Y&#x27;</span> || c == <span class="string">&#x27;y&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">Menu</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>银行家算法</title>
      <link href="/2023/04/29/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/"/>
      <url>/2023/04/29/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h3><p><strong>银行家算法是最有代表性的避免死锁的算法，由Dijkstra在1965年为T.H.E系统设计的一种避免死锁产生的算法啊。原本是为银行系统设计的，以确保银行在发放现金贷款是，不会发生不能满足所有客户需要的情况。</strong></p><p><strong>主要思想：</strong></p><p>当一个新的进程进入系统时，它必须申明它所需的最大资源数目，并且资源数目不能超过系统所拥有的资源总量。当进程请求一组资源时，系统必须要先确定是否由足够的资源能够分配给它，若有，先（假设）将资源分配给它，再判断系统是否处于不安全的状态。如果分配之后系统是安全的，则将资源分配给它，否则让进程等待。</p><h3 id="二、银行家算法中的数据结构"><a href="#二、银行家算法中的数据结构" class="headerlink" title="二、银行家算法中的数据结构"></a>二、银行家算法中的数据结构</h3><p>（1）最大需求矩阵Max。这是一个 $n*m$ 的矩阵，它定义了系统中n个进程中的每一个进程对m类资源的最大需求。如果 $Max[i][j] &#x3D; k$，则表示进程 $i$ 需要 $R_j$ 类资源的最大数目为 $k$ 。</p><p>（2）分配矩阵Allocation：这也是一个 $n*m$ 的矩阵，它定义了系统中的每一类资源当前已分配给每一进程的资源数。如果 $Allocation[i,j] &#x3D; K$，则表示进程 $i$ 当前已分得 $R_j$ 类资源的数目为 $K$ 。</p><p>（3）需求矩阵Need：这也是一个 $n*m$ 的矩阵，用以表示每一个进程尚需的各类资源数。如果 $Need[i,j] &#x3D; K$，则表示进程i还需要 $R_j$ 类资源 $K$ 个方能完成其任务。</p><p>（4）可利用资源向量AVALLABLE：这是一个含有 $m$ 个元素的数组，其中的每一个元素代表一类可用的资源数目，其初始值是系统中所配置的该类全部可用资源的数目，其数值随该类资源的分配和回收而动态地改变。如果 $Available[j] &#x3D; K$，则表示系统中现有 $Rj$ 类资源 $K$ 个。</p><p>其中：$Need[i,j] &#x3D; Max[i,j] - Allocation[i,j]$</p><h3 id="三、安全性算法"><a href="#三、安全性算法" class="headerlink" title="三、安全性算法"></a>三、安全性算法</h3><p>系统所执行的安全性算法可描述如下：</p><p>（1）设置两个向量：<br>        ① 工作向量Work: 它表示系统可提供给进程继续运行所需的各类资源数目，它含有m个元素，在执行安全算法开始时，Work&#x3D;Available;② Finish: 它表示系统是否有足够的资源分配给进程，使之运行完成。开始时先做Finish[i]&#x3D;false; 当有足够资源分配给进程时， 再令Finish[i]&#x3D;true。</p><p>（2）从进程集合中找到一个能满足下述条件的进程：<br>        ① $Finish［i］&#x3D;false$<br>        ② $Need［i，j］≤ work［j］$ 若找到， 执行步骤3)；否则，执行步骤4)。</p><p>（3）当进程Pi获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行：<br>        $work［j］&#x3D;Work［i］+Allocation［i,j］;$</p><p>​$Finish［i］&#x3D;true;$</p><p>​回到步骤（2）</p><p>（4）如果所有进程的 $Finish[i]&#x3D;true$ 都满足， 则表示系统处于安全状态；否则，系统处于不安全状态。</p><h3 id="四、银行家算法"><a href="#四、银行家算法" class="headerlink" title="四、银行家算法"></a>四、银行家算法</h3><p>设$Request$是进程 $P_i$ 的请求向量，如果表示进程Pi需要 $K$ 个 $R_j$ 类型的资源。当 $P_i$ 发出资源请求后，系统按下述步骤进行检查：</p><p>(1) 如果 $Request[j] ≤ Need[i,j]$，转向步骤(2)，否则认为出错，因为它所需的资源数目已超过它所宣布的最大值。</p><p>(2) 若 $Request[j] ≤ Available[j]$，转向步骤(3)，否则表示尚无足够资源，$P_i$必须等待。</p><p>(3) 系统尝试把资源分配给进程Pi，并修改下面数据结构中的数值：<br>$Available[j] &#x3D; Available[j] – Request[j]$<br>$Allocation[i,j] &#x3D; Allocation[i,j] + Request[j]$<br>$Need[i,j] &#x3D; Need[i,j] – Request[j]$</p><p>(4) 系统执行安全性算法，检查此次分配后系统是否处于安全状态。若安全，才正式分配给 $P_i$，完成此次分配；否则，此次试分配作废，恢复原来资源的分配状态，进程 $P_i$ 等待。</p><h3 id="五、代码实现"><a href="#五、代码实现" class="headerlink" title="五、代码实现"></a>五、代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; MAX, ALLOCATION, NEED;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; AVALLABLE, work;</span><br><span class="line">vector&lt;<span class="type">bool</span>&gt; FINISH;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Is_can</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; work, vector&lt;<span class="type">int</span>&gt;&amp; need)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> len = need.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (need[i] &gt; work[i]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入进程的数目:&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入资源的种类:&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; m;</span><br><span class="line">MAX.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>));<span class="comment">// 初始化MAX数组</span></span><br><span class="line">ALLOCATION.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>));<span class="comment">// 初始化已分配数组</span></span><br><span class="line">NEED.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>));<span class="comment">// 初始化NEED数组</span></span><br><span class="line">AVALLABLE.<span class="built_in">resize</span>(m + <span class="number">1</span>);<span class="comment">// 初始化可用资源数组</span></span><br><span class="line">work.<span class="built_in">resize</span>(m + <span class="number">1</span>);<span class="comment">// 初始化work数组</span></span><br><span class="line">FINISH.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="literal">false</span>);<span class="comment">// 初始化进程安全状态数组</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入每个进程最多所需的各类资源数，每种资源用空格隔开&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">cin &gt;&gt; MAX[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入每个进程已分配的各类资源数，每种资源用空格隔开&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">cin &gt;&gt; ALLOCATION[i][j];</span><br><span class="line">NEED[i][j] = MAX[i][j] - ALLOCATION[i][j];</span><br><span class="line"><span class="keyword">if</span> (NEED[i][j] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前进程所用的第&quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot;个资源数错误，请重新输入&quot;</span> &lt;&lt; endl;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入各类资源现有数量，每种资源用空格隔开&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">cin &gt;&gt; AVALLABLE[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全性算法</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Safe</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">work[i] = AVALLABLE[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">FINISH[i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (FINISH[i]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Is_can</span>(work, NEED[i])) &#123;</span><br><span class="line">FINISH[i] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">work[j] += ALLOCATION[i][j];</span><br><span class="line">&#125;</span><br><span class="line">res.<span class="built_in">push_back</span>(i);</span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (count == n) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;系统是安全的&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;安全序列如下&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">cout &lt;&lt; res[j] &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; res[n] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;系统是不安全的&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 银行家算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bank</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">request</span><span class="params">(m + <span class="number">1</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入申请资源的进程号（第一个进程的id为1，依次类推）&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; id;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入进程请求各类资源的数量&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">cin &gt;&gt; request[i];</span><br><span class="line"><span class="keyword">if</span> (request[i] &gt; NEED[id][i]) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请求资源数量 &gt; 进程需求量，请重新输入&quot;</span> &lt;&lt; endl;</span><br><span class="line">i--;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (request[i] &gt; AVALLABLE[i]) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请求资源数量 &gt; 系统现有资源数， 请重新输入&quot;</span> &lt;&lt; endl;</span><br><span class="line">i--;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">AVALLABLE[i] -= request[i];</span><br><span class="line">ALLOCATION[id][i] += request[i];</span><br><span class="line">NEED[id][i] -= request[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Safe</span>()) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;同意分配请求&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请求被拒绝&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">AVALLABLE[i] += request[i];</span><br><span class="line">ALLOCATION[id][i] -= request[i];</span><br><span class="line">NEED[id][i] += request[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">FINISH[i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="built_in">getchar</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;是否再次请求分配（Y/y）&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; c;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">&#x27;Y&#x27;</span> || c == <span class="string">&#x27;y&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">Init</span>();</span><br><span class="line"><span class="built_in">Safe</span>();</span><br><span class="line"><span class="built_in">Bank</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">3</span><br><span class="line">7 5 3</span><br><span class="line">3 2 2</span><br><span class="line">9 0 2</span><br><span class="line">2 2 2</span><br><span class="line">4 3 3</span><br><span class="line">0 1 0</span><br><span class="line">2 0 0</span><br><span class="line">3 0 2</span><br><span class="line">2 1 1</span><br><span class="line">0 0 2</span><br><span class="line">3 3 2</span><br></pre></td></tr></table></figure><h4 id="测试默认输出序列（不唯一）"><a href="#测试默认输出序列（不唯一）" class="headerlink" title="测试默认输出序列（不唯一）"></a>测试默认输出序列（不唯一）</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 4 1 3 5</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dijkstra算法</title>
      <link href="/2023/04/29/Dijkstra%E7%AE%97%E6%B3%95/"/>
      <url>/2023/04/29/Dijkstra%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="一、理解"><a href="#一、理解" class="headerlink" title="一、理解"></a>一、理解</h3><p><strong>Dijkstra算法时图论中最经典的最短路径算法，用于计算一个节点到其他节点的最短路径。它的主要是通过广度优先搜索+贪心思想实现的，以起点为中心向外扩散，直到扩散到所有的节点为止。具体为：首先找到当前点能够直接到达的点同时更新每一个点的最近距离，直到遍历完所有能到达的点为止。</strong></p><h3 id="二、基本步骤"><a href="#二、基本步骤" class="headerlink" title="二、基本步骤"></a>二、基本步骤</h3><ol><li>通过Dijkstra计算图map中的最短路径时，需要指定起点（即从起点s开始计算）。</li><li>此外需要引进两个数组dist和flag。dist的作用是记录每个从起点到每个顶点的最短距离，而flag时标记顶点是否已被访问（即当作顶点进行扩散遍历）。</li><li>初始时，dist中只有起点（并且距离为0），标记起点为已访问，然后将起点能够直接到达的点的距离添加进入dist数组。</li><li>然后从dist找出当前路径最短的点，并对其进行扩散遍历，更新当前点能够到达的顶点的的距离。</li><li>重复步骤4，直到遍历完所有的顶点。</li></ol><h3 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; map;</span><br><span class="line">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; dist;</span><br><span class="line">vector&lt;<span class="type">bool</span>&gt; flag;</span><br><span class="line"><span class="type">int</span> n, m, u, v, w, st;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;      <span class="comment">// 打印结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;小明：&quot;</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; <span class="string">&quot;要去的位置：&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (dist[i] == INT_MAX) cout &lt;&lt; <span class="string">&quot;sory， 无法到达&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;最短距离为：&quot;</span> &lt;&lt; dist[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dist[i] = map[t][i];    <span class="comment">// 初始化起点能够直接到达的点距离起点的距离</span></span><br><span class="line">    &#125;</span><br><span class="line">    dist[t] = <span class="number">0</span>;    <span class="comment">// 起点距离起点的距离为0</span></span><br><span class="line">    flag[t] = <span class="literal">true</span>;     <span class="comment">// 起点标记为已访问</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;   <span class="comment">// 更新除了起点以外的所有节点最小距离</span></span><br><span class="line">        <span class="type">int</span> minx = INT_MAX, mini = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;   <span class="comment">// 寻找当前未被标记并且距离起点最近的点，找到并记录下编号（即下标）</span></span><br><span class="line">            <span class="keyword">if</span> (!flag[j] &amp;&amp; dist[j] &lt; minx) &#123;</span><br><span class="line">                minx = dist[j];</span><br><span class="line">                mini = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        flag[mini] = <span class="literal">true</span>;  <span class="comment">// 将访问过的节点标记</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;   <span class="comment">// 更新当前节点能够直接到达的节点与起点的最短距离</span></span><br><span class="line">            <span class="keyword">if</span> (dist[mini] + map[mini][j] &lt; INT_MAX) &#123;</span><br><span class="line">                dist[j] = <span class="built_in">min</span>(dist[j], dist[mini] + map[mini][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入城市的个数：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    map.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, INT_MAX));</span><br><span class="line">    dist.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">    flag.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入城市之间的路线个数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入各城市之间的路线以及距离&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;       <span class="comment">// 初始化图</span></span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        map[u][v] = w;</span><br><span class="line">        map[v][u] = w;<span class="comment">// 有向图请注释掉本行代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入小明所在位置&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; st;</span><br><span class="line">    <span class="built_in">Dijkstra</span>(st);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;小明所在位置  &quot;</span> &lt;&lt; st &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LRU最近最久未使用最少置换算法</title>
      <link href="/2023/04/28/LRU%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E5%92%8C%E6%9C%80%E5%B0%91%E4%BD%BF%E7%94%A8%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/"/>
      <url>/2023/04/28/LRU%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E5%92%8C%E6%9C%80%E5%B0%91%E4%BD%BF%E7%94%A8%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="一、理解"><a href="#一、理解" class="headerlink" title="一、理解"></a>一、理解</h3><p><strong>LRU置换算法由于无法预测各页面将来的使用情况，只能利用“最近的过去”来作为”最近的将来“的近似，所以LRU算法选择将最近最久未使用的页面淘汰。</strong></p><p>​由于置换时需要淘汰的是最近最久未使用的页面，所以我们需要维持一个队列，根据最近未使用时间降序排列，类似于单调队列和单调栈。在这里我们使用两个栈（循环栈）实现。保持栈底始终为最近最久未使用的使用的页面号，栈顶始终最新被访问的页面的编号。</p><p><strong>例如：</strong>现有一进程，它分有3个物理块，所访问的页面的页面号序列为：4，7，0，7，1，0，1，2，1，2，6</p><p><strong>解释：</strong>在前三次访问时，依次将4、7、0放入栈中（这里的栈代表3个物理块），由于前三次需要访问的页面均不在栈中，所以都发生了缺页。在第4次访问页面时，因为页面在栈中，所以并没有发生缺页，故什么都不用做。在第5次访问时，由于需要访问的页面并不在栈中，所以发生了缺页，而此时栈又满了，故需要进行置换，将栈内最近最久未使用的页面换出去，将需要访问的页面换进来。具体如下表所示：</p><table><thead><tr><th>进程访问的页号</th><th>4</th><th>7</th><th>0</th><th>7</th><th>1</th><th>0</th><th>1</th><th>2</th><th>1</th><th>2</th><th>6</th></tr></thead><tbody><tr><td>块1</td><td></td><td></td><td>0</td><td>7</td><td>1</td><td>0</td><td>1</td><td>2</td><td>1</td><td>2</td><td>6</td></tr><tr><td>块2</td><td></td><td>7</td><td>7</td><td>0</td><td>7</td><td>1</td><td>0</td><td>1</td><td>2</td><td>1</td><td>2</td></tr><tr><td>块3</td><td>4</td><td>4</td><td>4</td><td>4</td><td>0</td><td>7</td><td>7</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>是否缺页</td><td>√</td><td>√</td><td>√</td><td></td><td>√</td><td></td><td></td><td>√</td><td></td><td></td><td>√</td></tr><tr><td>置换</td><td></td><td></td><td></td><td></td><td>√</td><td></td><td></td><td>√</td><td></td><td></td><td>√</td></tr></tbody></table><h3 id="二、具体代码实现（C-）"><a href="#二、具体代码实现（C-）" class="headerlink" title="二、具体代码实现（C++）"></a>二、具体代码实现（C++）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> P = <span class="number">3</span>;<span class="comment">// 进程分配的物理页数</span></span><br><span class="line"><span class="type">int</span> rs_size = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;    <span class="comment">// 存储置换次数</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; rs;     <span class="comment">// 存储需要使用的页面</span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; stk;     <span class="comment">// 模拟物理页面</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;     <span class="comment">// 用来记录当前页面是否已在虚拟存储区中，因为无序哈希表的时间复杂度为O(1)，查询效率高</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateRs</span><span class="params">()</span> </span>&#123;       <span class="comment">// 录入当前进程所需要的页面</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入逻辑空间的页面个数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        cin &gt;&gt; rs_size;</span><br><span class="line">        <span class="keyword">if</span> (rs_size &gt; <span class="number">50</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;页面个数超出进程空间的最大范围，请重新输入&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rs.<span class="built_in">resize</span>(rs_size + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入进程页面，用空格隔开&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= rs_size; i++) &#123;</span><br><span class="line">        cin &gt;&gt; rs[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;      <span class="comment">// 打印出当前虚拟存储区中的页面</span></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        st.<span class="built_in">push</span>(stk.<span class="built_in">top</span>());</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> t = st.<span class="built_in">top</span>();</span><br><span class="line">        cout &lt;&lt; t &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        stk.<span class="built_in">push</span>(t);</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap_Page</span><span class="params">(<span class="type">int</span> page)</span> </span>&#123;      <span class="comment">// 页面对换</span></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk1;</span><br><span class="line">    <span class="keyword">if</span> (mp[page] == <span class="number">1</span>) &#123;<span class="comment">// 如果当前需要访问的页面本来就在虚拟存储区中（即栈中），就将它移动到栈顶</span></span><br><span class="line">        <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> t = stk.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (t == page) &#123;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">while</span> (!stk1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    stk.<span class="built_in">push</span>(stk1.<span class="built_in">top</span>());</span><br><span class="line">                    stk1.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                stk.<span class="built_in">push</span>(page);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stk1.<span class="built_in">push</span>(t);</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 当前需要访问的页面并不在栈中，这时我们需要移除栈底页面，同时把当前页面加入到栈顶</span></span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">while</span> (stk.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> t = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk1.<span class="built_in">push</span>(t);</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        mp[stk.<span class="built_in">top</span>()] = <span class="number">0</span>;<span class="comment">// 由于栈底页面被移出了栈，所以标记该页面为0，表示该页面已不在栈中</span></span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">while</span> (!stk1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            stk.<span class="built_in">push</span>(stk1.<span class="built_in">top</span>());</span><br><span class="line">            stk1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        stk.<span class="built_in">push</span>(page);</span><br><span class="line">        mp[page] = <span class="number">1</span>;<span class="comment">// 将当前需要访问的页面加入到栈顶，并标记为在栈中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;       <span class="comment">// 入口函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= rs_size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= P) &#123;</span><br><span class="line">            stk.<span class="built_in">push</span>(rs[i]);<span class="comment">// 将当前页面加入到栈中</span></span><br><span class="line">            mp[rs[i]] = <span class="number">1</span>;<span class="comment">// 标记该元素已在栈中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">Swap_Page</span>(rs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;总共发生了&quot;</span> &lt;&lt; cnt &lt;&lt; <span class="string">&quot;次页面置换&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">CreateRs</span>();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试案例1"><a href="#测试案例1" class="headerlink" title="测试案例1"></a>测试案例1</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">11</span><br><span class="line">4 7 0 7 1 0 1 2 1 2 6</span><br></pre></td></tr></table></figure><p>结果为发生了3次对换</p><h4 id="测试案列2"><a href="#测试案列2" class="headerlink" title="测试案列2"></a>测试案列2</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">20</span><br><span class="line">7 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 7 0 1</span><br></pre></td></tr></table></figure><p>结果为发生了9次对换</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>康托展开</title>
      <link href="/2023/04/23/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/"/>
      <url>/2023/04/23/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/</url>
      
        <content type="html"><![CDATA[<h3 id="一、理解"><a href="#一、理解" class="headerlink" title="一、理解"></a>一、理解</h3><p><strong>康托展开是一种特殊的哈希函数，是一个全排列到一个自然数的双射，常用于构建哈希表时的空间压缩。实质是计算当前排列在所有由小到大全排列中的序号，所以是可逆的。</strong></p><ol><li>康托展开公式：$X&#x3D;a_n(n - 1)! + a_{n - 1}(n - 2)! + ··· +a_1*0!$</li><li>解释：$a_i$ 的意思是从右往左数第i位这个数是这个数前未出现的数，第 $a_i$ 大</li><li>举例：例如52413<ol><li>首先看第一个数5，不管第一位是什么数，后面都有四位数，那么这四位数全排列的方式有 4! 种，而如果第一位是1或2或3或4都会比5开头的字典序要小，所以可以令1，2，3，4分别作为开头，这样的话就会有4 * 4! 种解法要比52413这种排法的字典序要小。</li><li>除了前面所说的排列方式还有比52413的字典序小的排列方式。我们可以先固定第一位为5，找下一位2，这时候5已经用过，所以只能从剩下的1，2，3，4里面挑选比2小的数，很显然只有1，然后在2的后面还有3位数，也就是在这时又找到了 3! 种排列方式。</li><li>后面固定前两位，固定前3位······以此类推。</li><li>所以52413的康托展开计算值应为：  $4\times4!+1\times3!+2\times2!+0\times1!+0\times0!&#x3D;107$</li></ol></li></ol><h3 id="二、康托展开代码实现"><a href="#二、康托展开代码实现" class="headerlink" title="二、康托展开代码实现"></a>二、康托展开代码实现</h3><h4 id="1-正向展开"><a href="#1-正向展开" class="headerlink" title="1.正向展开"></a>1.正向展开</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[<span class="number">2000</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提前计算出1 - n的阶乘</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[<span class="number">0</span>] = f[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 0的阶乘为1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) f[i] = f[i - <span class="number">1</span>] * i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 康托展开</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kangtuo</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;    <span class="comment">//注意，因为 12345 是算作0开始计算的，最后结果要把12345看作是第一个</span></span><br><span class="line">    <span class="type">int</span> len = str.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">0</span>;    <span class="comment">//用来计数的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] &gt; str[j]) tmp++;     <span class="comment">//计算str[i]是第几大的数，或者说计算有几个比他小的数</span></span><br><span class="line">        &#125;</span><br><span class="line">        ans += tmp * f[len - i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">factorial</span>(<span class="number">10</span>);</span><br><span class="line">    string str = <span class="string">&quot;52413&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">kangtuo</span>(str) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-逆向展开"><a href="#2-逆向展开" class="headerlink" title="2.逆向展开"></a>2.逆向展开</h4><p>逆向展开就是正向展开的逆运算，例如：第一个序列位12345，求第107个序列。</p><ol><li><p>先将107减1，因为康托展开的初始序列编号为0</p></li><li><p>因为序列的长度为5，依次计算 $4!,3!,2!,1!,0!$ 的后缀积</p><p>106 &#x2F; 4! &#x3D; 4 mod 10 可以知道有4个数比第一位数小，此时只有（1，2，3，4，5）可选，所以第一位应为5</p><p>10   &#x2F; 3! &#x3D; 1 mod 4   可以知道有1个数比第二位数小，此时只有（1，2，3，4）可选，所以第二位应为2</p><p>4     &#x2F; 2! &#x3D; 2 mod 0   可以知道有2个数比第三位数小，此时只有（1，3，4）可选，所以第三位应为4</p><p>0     &#x2F; 1! &#x3D; 0 mod 0   可以知道有0个数比第四位数小，此时只有（1，3）可选，所以第四位应为1</p><p>此时只有（3）可选，所以第五位就是3</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[<span class="number">2000</span>];</span><br><span class="line"><span class="type">int</span> x, num;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提前计算出1 - n的阶乘</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    f[<span class="number">0</span>] = f[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 0的阶乘为1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) f[i] = f[i - <span class="number">1</span>] * i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">char</span>&gt; vec; <span class="comment">//存需要排列的字符</span></span><br><span class="line"><span class="comment">// 康托逆展开</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rev_kangtuo</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = vec.<span class="built_in">size</span>(), len = <span class="number">0</span>;</span><br><span class="line">    string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    k--;    <span class="comment">// 算的时候是按 12345 是第0位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> t = k / f[n - i];   <span class="comment">// 第 i 位需要 第 t + 1 大的数</span></span><br><span class="line">        k %= f[n - i];        <span class="comment">// 剩下的几位需要提供的排列数</span></span><br><span class="line">        ans += vec[t];      <span class="comment">// vec[t] 就是第 t + 1 大的数</span></span><br><span class="line">        vec.<span class="built_in">erase</span>(vec.<span class="built_in">begin</span>() + t);     <span class="comment">// 删除用过的字符</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;    <span class="comment">//输出序号为 k 的字符序列</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">factorial</span>(<span class="number">10</span>);  <span class="comment">// 预处里好阶乘</span></span><br><span class="line">    cin &gt;&gt; x;    <span class="comment">// 输入需要逆展开的数字</span></span><br><span class="line">    <span class="comment">// 康托逆展开</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (x / f[i] == <span class="number">0</span>) <span class="comment">// 求出 x 逆展开所需的最小的位数，方便下面的初始化</span></span><br><span class="line">        &#123;</span><br><span class="line">            num = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num; i++) vec.<span class="built_in">push_back</span>(i + <span class="string">&#x27;0&#x27;</span>); <span class="comment">//输入的位数只要不小于num就可以</span></span><br><span class="line">    <span class="built_in">rev_kangtuo</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++集合set</title>
      <link href="/2023/04/23/C++%E9%9B%86%E5%90%88set/"/>
      <url>/2023/04/23/C++%E9%9B%86%E5%90%88set/</url>
      
        <content type="html"><![CDATA[<h3 id="一、set的特点"><a href="#一、set的特点" class="headerlink" title="一、set的特点"></a>一、set的特点</h3><p>​STL的set使用二叉搜索树实现，集合中的每一个元素只出现一次，并且是排好序的，访问元素的时间复杂度为O(log<del>2</del>n) ，效率很高。</p><h3 id="二、set的相关操作"><a href="#二、set的相关操作" class="headerlink" title="二、set的相关操作"></a>二、set的相关操作</h3><table><thead><tr><th>操作</th><th>功能</th></tr></thead><tbody><tr><td>set&lt;Type&gt; A</td><td>定义set</td></tr><tr><td>insert(val)</td><td>把val插入set中</td></tr><tr><td>erase(val)</td><td>将val从set中删除</td></tr><tr><td>clear()</td><td>清空set中的元素</td></tr><tr><td>empty()</td><td>判断set是否为空（如果为空返回true，否则返回false）</td></tr><tr><td>size()</td><td>返回set中的元素个数</td></tr><tr><td>find(k)</td><td>返回一个迭代器，指向键值k</td></tr><tr><td>lower_bound(k)</td><td>返回一个迭代器，指向键值不小于k的第一个元素</td></tr><tr><td>upper_bound(k)</td><td>返回一个迭代器，指向键值大于k的第一个元素</td></tr><tr><td>begin()</td><td>返回容器的第一个元素</td></tr><tr><td>end()</td><td>返回容器的最后一个元素的索引（如需访问这需要cout &lt;&lt; *(–A.end()) &lt;&lt; endl;）</td></tr></tbody></table><h3 id="三、使用示例"><a href="#三、使用示例" class="headerlink" title="三、使用示例"></a>三、使用示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(set&lt;<span class="type">int</span>&gt; a)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;集合中当前的元素为：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator i = a.<span class="built_in">begin</span>(); i != a.<span class="built_in">end</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">se</span><span class="params">(a.begin(), a.end())</span></span>;    <span class="comment">// 构造并初始化set容器</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;se的初始值为：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">print</span>(se);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入</span></span><br><span class="line">    se.<span class="built_in">insert</span>(<span class="number">6</span>);</span><br><span class="line">    <span class="built_in">print</span>(se);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    se.<span class="built_in">erase</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">print</span>(se);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素</span></span><br><span class="line">    set&lt;<span class="type">int</span>&gt;::iterator iter;    <span class="comment">// 定义迭代器</span></span><br><span class="line">    iter = se.<span class="built_in">find</span>(<span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;找到了元素： &quot;</span>;</span><br><span class="line">    cout &lt;&lt; *iter &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// begin() 和 end()</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;set的第一个元素为：&quot;</span> &lt;&lt; *se.<span class="built_in">begin</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 这里需要注意end()返回的是最后一个元素的索引</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;set的最后一个元素为：&quot;</span> &lt;&lt; *(--se.<span class="built_in">end</span>()) &lt;&lt; endl &lt;&lt; endl;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// lower_bound() 和 upper_bound()</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一个键值不大于2的元素为：&quot;</span> &lt;&lt; *se.<span class="built_in">lower_bound</span>(<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一个键值大于2的元素为：&quot;</span> &lt;&lt; *se.<span class="built_in">upper_bound</span>(<span class="number">2</span>) &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、自定义排序规则"><a href="#四、自定义排序规则" class="headerlink" title="四、自定义排序规则"></a>四、自定义排序规则</h3><h4 id="1-元素类型基本数据类型"><a href="#1-元素类型基本数据类型" class="headerlink" title="1. 元素类型基本数据类型"></a>1. 元素类型基本数据类型</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cmp</span> &#123;    <span class="comment">// 按照从大到小的方式排序（set默认是从小到大）</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a, <span class="type">const</span> <span class="type">int</span>&amp; b)</span> <span class="type">const</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(set&lt;<span class="type">int</span>, cmp&gt; a)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;集合中当前的元素为：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (set&lt;<span class="type">int</span>, cmp&gt;::iterator i = a.<span class="built_in">begin</span>(); i != a.<span class="built_in">end</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="function">set&lt;<span class="type">int</span>, cmp&gt; <span class="title">se</span><span class="params">(a.begin(), a.end())</span></span>;    <span class="comment">// 构造并初始化set容器</span></span><br><span class="line">    <span class="built_in">print</span>(se);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果如下：</span><br><span class="line">集合中当前的元素为：</span><br><span class="line"><span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="2-元素类型为复合数据类型"><a href="#2-元素类型为复合数据类型" class="headerlink" title="2.元素类型为复合数据类型"></a>2.元素类型为复合数据类型</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">stu</span> &#123;    <span class="comment">// 按照从大到小的方式排序</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> no;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> stu&amp; a) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> no &gt; a.no;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(set&lt;stu&gt; a)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;集合中当前的元素为：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (set&lt;stu&gt;::iterator i = a.<span class="built_in">begin</span>(); i != a.<span class="built_in">end</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; (*i).name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (*i).no &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;stu&gt; a&#123; &#123; <span class="string">&quot;zhangsan&quot;</span>, <span class="number">1</span> &#125;, &#123; <span class="string">&quot;lisi&quot;</span>, <span class="number">2</span> &#125;, &#123; <span class="string">&quot;wangwu&quot;</span>, <span class="number">3</span> &#125; , &#123; <span class="string">&quot;xiaoming&quot;</span>, <span class="number">4</span> &#125;, &#123; <span class="string">&quot;xiaowang&quot;</span>, <span class="number">5</span> &#125; &#125;;</span><br><span class="line">    <span class="function">set&lt;stu&gt; <span class="title">se</span><span class="params">(a.begin(), a.end())</span></span>;    <span class="comment">// 构造并初始化set容器</span></span><br><span class="line">    <span class="built_in">print</span>(se);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果如下：</span><br><span class="line">集合中当前的元素为：</span><br><span class="line">xiaowang <span class="number">5</span></span><br><span class="line">xiaoming <span class="number">4</span></span><br><span class="line">wangwu <span class="number">3</span></span><br><span class="line">lisi <span class="number">2</span></span><br><span class="line">zhangsan <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++链表与list</title>
      <link href="/2023/04/16/C++%E9%93%BE%E8%A1%A8%E4%B8%8EList/"/>
      <url>/2023/04/16/C++%E9%93%BE%E8%A1%A8%E4%B8%8EList/</url>
      
        <content type="html"><![CDATA[<h3 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h3><p><strong>STL中的List是数据结构中的双向链表，可以通过指针来进行数据的访问，它可以高效地再任意地方插入和删除，时间复杂度为常数级。主要用于插入和删除频繁，随机访问较少的场景。</strong></p><h3 id="二、应用"><a href="#二、应用" class="headerlink" title="二、应用"></a>二、应用</h3><h4 id="1-list的构造函数"><a href="#1-list的构造函数" class="headerlink" title="1.list的构造函数"></a>1.list的构造函数</h4><table><thead><tr><th>构造函数</th><th>接口说明</th></tr></thead><tbody><tr><td>list()</td><td>构造空的list</td></tr><tr><td>list(size_type n, const value_type&amp; val &#x3D; value_type())</td><td>构造的list中包含n个值为val的元素</td></tr><tr><td>list(const list&amp; x)</td><td>拷贝构造函数</td></tr><tr><td>list(InputIterator first, Inputlterator last)</td><td>用[first, last)区间中的元素构造list</td></tr></tbody></table><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; l1;<span class="comment">// 构造一个int类型的空容器</span></span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">l2</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span></span>;<span class="comment">// 构造一个长度为10的int类型容器（即拥有十个节点的双向链表）</span></span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">l3</span><span class="params">(l2)</span></span>;<span class="comment">// 拷贝构造一个与l2相同的容器（即创建一个新容器，并将l2的数据拷贝过来）</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; array&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">l4</span><span class="params">(array.begin(), array.end())</span></span>;<span class="comment">// 利用迭代器构造新容器</span></span><br></pre></td></tr></table></figure><h4 id="2-list的插入和删除"><a href="#2-list的插入和删除" class="headerlink" title="2.list的插入和删除"></a>2.list的插入和删除</h4><table><thead><tr><th>函数声明</th><th>接口说明</th></tr></thead><tbody><tr><td>push_front(val)</td><td>在list首元素前插入值为val的元素</td></tr><tr><td>pop_front()</td><td>删除list中第一个元素</td></tr><tr><td>push_back(val)</td><td>在list尾部插入值为val的元素</td></tr><tr><td>pop_back()</td><td>删除list中最后一个元素</td></tr><tr><td>insert(int position, val)</td><td>在list中位置为position的位置插入一个值为val的元素</td></tr><tr><td>erase(int position)</td><td>删除在list中位置为2的元素</td></tr></tbody></table><h4 id="3-list迭代器的使用"><a href="#3-list迭代器的使用" class="headerlink" title="3.list迭代器的使用"></a>3.list迭代器的使用</h4><table><thead><tr><th>函数声明</th><th>接口说明</th></tr></thead><tbody><tr><td>begin + end</td><td>返回第一个元素的迭代器 + 返回最后一个元素的下一个位置的迭代器</td></tr><tr><td>rbegin + rend</td><td>返回第一个元素的reverse_iterator, 即end位置，返回最后一个元素下一个位置的reverse_iterator,即begin位置</td></tr></tbody></table><p><strong>其中begin 和 end为正向迭代器，rbegin 和 rend为反向迭代器</strong></p><h4 id="4-list获取头尾元素"><a href="#4-list获取头尾元素" class="headerlink" title="4.list获取头尾元素"></a>4.list获取头尾元素</h4><table><thead><tr><th>函数声明</th><th>接口说明</th></tr></thead><tbody><tr><td>front</td><td>返回list的第一个节点中值的引用</td></tr><tr><td>back</td><td>返回list的最后一个节点中值的引用</td></tr></tbody></table><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; array&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">L</span><span class="params">(array.begin(), array.end())</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; L.<span class="built_in">front</span>() &lt;&lt; endl;<span class="comment">// 输出list首部元素</span></span><br><span class="line">    cout &lt;&lt; L.<span class="built_in">back</span>() &lt;&lt; endl;<span class="comment">// 输出list尾部元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-获取list的大小"><a href="#5-获取list的大小" class="headerlink" title="5.获取list的大小"></a>5.获取list的大小</h4><table><thead><tr><th>函数声明</th><th>接口说明</th></tr></thead><tbody><tr><td>empty</td><td>判断list是否为空， 为空则返回true，否则返回false</td></tr><tr><td>size</td><td>返回list的长度（即链表的有效长度）</td></tr></tbody></table><h4 id="6-list的功能函数"><a href="#6-list的功能函数" class="headerlink" title="6.list的功能函数"></a>6.list的功能函数</h4><table><thead><tr><th>函数声明</th><th>接口说明</th></tr></thead><tbody><tr><td>swap(list l1, list l2)</td><td>用交换两个list容器的内容（即交换l1和l2的内容）</td></tr><tr><td>clear</td><td>用于清空整个容器，清空后容器的size为0</td></tr><tr><td>sort</td><td>将容器的数据排序（默认为升序）</td></tr><tr><td>resize</td><td>重设容器的大小</td></tr><tr><td>remove</td><td>移除指定元素</td></tr><tr><td>unique</td><td>去除list中重复的元素</td></tr><tr><td>reverse</td><td>逆转list容器，即翻转链表</td></tr></tbody></table><h3 id="三、例题"><a href="#三、例题" class="headerlink" title="三、例题"></a>三、例题</h3><h4 id="士兵队列训练问题"><a href="#士兵队列训练问题" class="headerlink" title="士兵队列训练问题"></a>士兵队列训练问题</h4><p>一队士兵报数：从头开始进行1至2报数，凡报到2的出列，剩下的向小序号方向靠拢，再从头开始进行1至3报数，凡报到3的士兵出列，剩下的向小序号方向靠拢，以后从头开始轮流进行1至2报数、1至3报数，直到剩下的人数不超过3为止。</p><p>​输入：士兵人数<br>​输出：剩下士兵最初的编号</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> t, n;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span> (t--) &#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="type">int</span> k = <span class="number">2</span>;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; L;<span class="comment">// 构造一个空的list</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator it;<span class="comment">// 生命迭代器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">L.<span class="built_in">push_back</span>(i);<span class="comment">// 给list赋值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (L.<span class="built_in">size</span>() &gt; <span class="number">3</span>) &#123;</span><br><span class="line"><span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); ) &#123;</span><br><span class="line"><span class="keyword">if</span> (num++ % k == <span class="number">0</span>) &#123;</span><br><span class="line">it = L.<span class="built_in">erase</span>(it);<span class="comment">// 删除元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">it++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">k == <span class="number">2</span> ? k = <span class="number">3</span> : k = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;<span class="comment">// 迭代遍历list并输出元素</span></span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="/2023/04/09/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
      <url>/2023/04/09/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="一、理解"><a href="#一、理解" class="headerlink" title="一、理解"></a>一、理解</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p><strong>归并排序实质上是一种分治算法，分而治之，就是将一个大问题分解为若干个较小规模的问题，解决完每个小问题后再串联起来。</strong></p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><h5 id="1-分解："><a href="#1-分解：" class="headerlink" title="1.分解："></a>1.分解：</h5><p>将要解决的问题分解为若干个规模较小、相互独立、与原问题形式相同的子问题。</p><h5 id="2-治理："><a href="#2-治理：" class="headerlink" title="2.治理："></a>2.治理：</h5><p>求解各个子问题。由于各个子问题与原问题形式相同，只是规模较小而已，而当子问题划分的足够小时，就可以用简单的方法来解决。</p><h5 id="3-合并："><a href="#3-合并：" class="headerlink" title="3.合并："></a>3.合并：</h5><p>按照原问题的要求，将子问题的解逐层合并成原问题的解。</p><h5 id="4-算法分析："><a href="#4-算法分析：" class="headerlink" title="4.算法分析："></a>4.算法分析：</h5><p>首先我们先给一个无序的数列（42， 15， 20， 6， 8， 38， 50， 12），我们进行归并排序数列，流程如下图所示：</p><p><img src="https://i.postimg.cc/wTtjnDvw/fd1e5ee39edc41ff812daad1fbe18e2d.png"></p><ol><li>首先将待排序的元素分成大小大致相同的两个序列。</li><li>再把子序列分成大小相同的两个子序列。</li><li>如此下去，直到分解成一个元素截至，这是含有一个元素的子序列都是有序的。</li><li>最后进行合并操作，将两个有序的子序列合并为一个有序序列，如此下去，直到所有的元素都合并为一个有序序列。</li></ol><h3 id="二、具体实现："><a href="#二、具体实现：" class="headerlink" title="二、具体实现："></a>二、具体实现：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merage</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; List, <span class="type">int</span> l, <span class="type">int</span> mid, <span class="type">int</span> r)</span> </span>&#123;<span class="comment">// 合并函数</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"><span class="type">int</span> i = l, j = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line"><span class="keyword">if</span> (List[i] &lt;= List[j]) res.<span class="built_in">push_back</span>(List[i++]);</span><br><span class="line"><span class="keyword">else</span> res.<span class="built_in">push_back</span>(List[j++]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid) res.<span class="built_in">push_back</span>(List[i++]);</span><br><span class="line"><span class="keyword">while</span> (j &lt;= r) res.<span class="built_in">push_back</span>(List[j++]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = l; k &lt;= r; k++) List[k] = res[k - l];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merageSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; List, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;<span class="comment">// 归并排序函数</span></span><br><span class="line"><span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">merageSort</span>(List, left, mid);<span class="comment">// 分治</span></span><br><span class="line"><span class="built_in">merageSort</span>(List, mid + <span class="number">1</span>, right);</span><br><span class="line"><span class="built_in">merage</span>(List, left, mid, right);<span class="comment">// 合并</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; List = &#123; <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">merageSort</span>(List, <span class="number">0</span>, <span class="number">9</span>);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) cout &lt;&lt; List[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++优先队列priority_queue</title>
      <link href="/2023/04/04/C++%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97priority_queue/"/>
      <url>/2023/04/04/C++%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97priority_queue/</url>
      
        <content type="html"><![CDATA[<h3 id="一、priority-queue简介"><a href="#一、priority-queue简介" class="headerlink" title="一、priority_queue简介"></a>一、priority_queue简介</h3><ol><li><strong>优先队列是一种容器适配器，根据严格的弱排序标准，它的第一个元素总是它所包含的元素中最大的。</strong></li><li><strong>类似于堆，在堆中可以随时插入元素，并且只能检索最大堆元素(优先队列中位于顶部的元素)。</strong></li><li><strong>优先队列被实现为容器适配器，容器适配器即将特定容器类封装作为其底层容器类。元素从特定容器的“尾部”弹出，其称为优先队列的顶部。</strong></li><li><strong>底层容器可以是任何标准容器类模板，也可以是其他特定设计的容器类。容器应该可以通过随机访问迭代器访问，并支持以下操作：empty() 检测容器是否为空，size()：返回容器中有效元素个数，front()：返回容器中第一个元素的引用，push_back()：在容器尾部插入元素，pop_back()：删除容器尾部元素。</strong></li><li><strong>标准容器类vector和deque满足这些需求。默认情况下，如果没有为特定的priority_queue类实例化指定容器类，则使用vector。</strong></li><li><strong>需要支持随机访问迭代器，以便始终在内部保持堆结构。容器适配器通过在需要时自动调用算法函数make_heap、push_heap和pop_heap来自动完成此操作。</strong></li></ol><h3 id="二、priority-queue类常用接口"><a href="#二、priority-queue类常用接口" class="headerlink" title="二、priority_queue类常用接口"></a>二、priority_queue类常用接口</h3><table><thead><tr><th>函数名称</th><th>功能说明</th></tr></thead><tbody><tr><td>priority_queue()</td><td>构造一个空的优先级队列</td></tr><tr><td>priority_queue(first,last)</td><td>构造一个空的优先级队列</td></tr><tr><td>empty()</td><td>检测优先级队列是否为空，是返回true，否则返回false</td></tr><tr><td>top( )</td><td>返回优先级队列中最大&#x2F;最小元素，即堆顶元素</td></tr><tr><td>push(X)</td><td>在优先级队列中插入元素X</td></tr><tr><td>pop()</td><td>删除优先级队列中最大&#x2F;最小元素，即堆顶元素</td></tr></tbody></table><p><strong>示例</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123; <span class="number">10</span>,<span class="number">60</span>,<span class="number">50</span>,<span class="number">20</span> &#125;;</span><br><span class="line"><span class="comment">//priority_queue&lt;int&gt; pq;</span></span><br><span class="line"><span class="function">priority_queue&lt;<span class="type">int</span>&gt; <span class="title">pq</span><span class="params">(v.begin(),v.end())</span></span>;</span><br><span class="line">pq.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line"><span class="keyword">while</span> (!pq.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt; pq.<span class="built_in">top</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">pq.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、priority类的使用"><a href="#三、priority类的使用" class="headerlink" title="三、priority类的使用"></a>三、priority类的使用</h3><p>​<strong>默认情况下，priority_queue是创建的是大堆，其底层按照小于号比较，默认模板参数为template&lt;class T, class Container &#x3D;std::vector<T>, class Compare &#x3D; std::less<T>&gt;；如果要创建小堆，将第三个模板参数换成greater即可，例如priority_queue&lt;int, vector<int>, greater<int>&gt; pq2(v.begin(), v.end());</strong></p><p>​对于<code>greater&lt;int&gt;</code>和<code>less&lt;T&gt;</code></p><p><strong>greater和less的头文件为#include <functional>，具体实现见第三节模拟实现部分。 <functional>是C++标准库中的一个头文件，定义了C++标准中多个用于表示函数对象的类模板，包括算法操作、比较操作、逻辑操作；</strong></p><p>  建堆时，less<T>是大顶堆，堆元素是从大到小；greater<T>是小顶堆，堆元素是从小到大。</p><p>  排序时，less<T>是升序，数组元素是从小到大；greater<T>是降序堆，数组元素是从大到小。</p><ol><li><strong>如果priority_queue中放自定义类型的数据，需要在自定义类型中提供&gt; 或者&lt; 的重载</strong></li></ol><h5 id="方式1：使用类对象创建"><a href="#方式1：使用类对象创建" class="headerlink" title="方式1：使用类对象创建"></a>方式1：使用类对象创建</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//函数对象类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cmp</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//重载 () 运算符</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123; <span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,cmp&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">pq</span>(a,a+<span class="number">5</span>);<span class="comment">//第三个传入参数cmp制定自定义的排序方式</span></span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; pq.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方式2：使用struct关键字创建"><a href="#方式2：使用struct关键字创建" class="headerlink" title="方式2：使用struct关键字创建"></a>方式2：使用struct关键字创建</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line"> <span class="comment">//重载()运算符</span></span><br><span class="line"> <span class="function"><span class="type">bool</span> <span class="title">operater</span><span class="params">()</span><span class="params">(T a,T b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="std-less-和-std-greater-的底层实现方式："><a href="#std-less-和-std-greater-的底层实现方式：" class="headerlink" title="std::less 和 std::greater 的底层实现方式："></a>std::less 和 std::greater 的底层实现方式：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::less&lt;T&gt; 的底层实现代码</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">less</span> &#123;</span><br><span class="line">    <span class="comment">//定义新的排序规则</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T &amp;_lhs, <span class="type">const</span> T &amp;_rhs)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _lhs &lt; _rhs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// std::greater&lt;T&gt; 的底层实现代码</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">greater</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T &amp;_lhs, <span class="type">const</span> T &amp;_rhs)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _lhs &gt; _rhs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vector</title>
      <link href="/2023/04/04/C++%20vector%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
      <url>/2023/04/04/C++%20vector%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="C-vector基本用法"><a href="#C-vector基本用法" class="headerlink" title="C++ vector基本用法"></a>C++ vector基本用法</h1><p><strong>vector 是向量类型，它可以容纳许多类型的数据，如若干个整数，所以称其为容器。vector 是C++ STL的一个重要成员，使用它时需要包含头文件：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;vector&gt;;</span><br></pre></td></tr></table></figure><h4 id="一、vector-的初始化：可以有五种方式-举例说明如下："><a href="#一、vector-的初始化：可以有五种方式-举例说明如下：" class="headerlink" title="一、vector 的初始化：可以有五种方式,举例说明如下："></a>一、vector 的初始化：可以有五种方式,举例说明如下：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> (<span class="number">1</span>) <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//定义了10个整型元素的向量（尖括号中为元素类型名，它可以是任何合法的数据类型），但没有给出初值，其值是不确定的。</span></span><br><span class="line">（<span class="number">2</span>）<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>,<span class="number">1</span>)</span></span>; <span class="comment">//定义了10个整型元素的向量,且给出每个元素的初值为1</span></span><br><span class="line">（<span class="number">3</span>）<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(b)</span></span>; <span class="comment">//用b向量来创建a向量，整体复制性赋值</span></span><br><span class="line">（<span class="number">4</span>）<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(b.begin(),b.begin+<span class="number">3</span>)</span></span>; <span class="comment">//定义了a值为b中第0个到第2个（共3个）元素</span></span><br><span class="line">（<span class="number">5</span>）<span class="type">int</span> b[<span class="number">7</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">8</span>&#125;;</span><br><span class="line">     <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(b,b+<span class="number">7</span>)</span></span>; <span class="comment">//从数组中获得初值</span></span><br></pre></td></tr></table></figure><h4 id="二、vector对象的几个重要操作，举例说明如下："><a href="#二、vector对象的几个重要操作，举例说明如下：" class="headerlink" title="二、vector对象的几个重要操作，举例说明如下："></a>二、vector对象的几个重要操作，举例说明如下：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）a.<span class="built_in">assign</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">begin</span>()+<span class="number">3</span>); <span class="comment">//b为向量，将b的0~2个元素构成的向量赋给a</span></span><br><span class="line">（<span class="number">2</span>）a.<span class="built_in">assign</span>(<span class="number">4</span>,<span class="number">2</span>); <span class="comment">//是a只含4个元素，且每个元素为2</span></span><br><span class="line">（<span class="number">3</span>）a.<span class="built_in">back</span>(); <span class="comment">//返回a的最后一个元素</span></span><br><span class="line">（<span class="number">4</span>）a.<span class="built_in">front</span>(); <span class="comment">//返回a的第一个元素</span></span><br><span class="line">（<span class="number">5</span>）a[i]; <span class="comment">//返回a的第i个元素，当且仅当a[i]存在2013-12-07</span></span><br><span class="line">（<span class="number">6</span>）a.<span class="built_in">clear</span>(); <span class="comment">//清空a中的元素</span></span><br><span class="line">（<span class="number">7</span>）a.<span class="built_in">empty</span>(); <span class="comment">//判断a是否为空，空则返回ture,不空则返回false</span></span><br><span class="line">（<span class="number">8</span>）a.<span class="built_in">pop_back</span>(); <span class="comment">//删除a向量的最后一个元素</span></span><br><span class="line">（<span class="number">9</span>）a.<span class="built_in">erase</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,a.<span class="built_in">begin</span>()+<span class="number">3</span>); <span class="comment">//删除a中第1个（从第0个算起）到第2个元素，也就是说删除的元素从a.begin()+1算起（包括它）一直到a.begin()+         3（不包括它）</span></span><br><span class="line">（<span class="number">10</span>）a.<span class="built_in">push_back</span>(<span class="number">5</span>); <span class="comment">//在a的最后一个向量后插入一个元素，其值为5</span></span><br><span class="line">（<span class="number">11</span>）a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,<span class="number">5</span>); <span class="comment">//在a的第1个元素（从第0个算起）的位置插入数值5，如a为1,2,3,4，插入元素后为1,5,2,3,4</span></span><br><span class="line">（<span class="number">12</span>）a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>); <span class="comment">//在a的第1个元素（从第0个算起）的位置插入3个数，其值都为5</span></span><br><span class="line">（<span class="number">13</span>）a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,b+<span class="number">3</span>,b+<span class="number">6</span>); <span class="comment">//b为数组，在a的第1个元素（从第0个算起）的位置插入b的第3个元素到第5个元素（不包括b+6），如b为1,2,3,4,5,9,8         ，插入元素后为1,4,5,9,2,3,4,5,9,8</span></span><br><span class="line">（<span class="number">14</span>）a.<span class="built_in">size</span>(); <span class="comment">//返回a中元素的个数；</span></span><br><span class="line">（<span class="number">15</span>）a.<span class="built_in">capacity</span>(); <span class="comment">//返回a在内存中总共可以容纳的元素个数</span></span><br><span class="line">（<span class="number">16</span>）a.<span class="built_in">resize</span>(<span class="number">10</span>); <span class="comment">//将a的现有元素个数调至10个，多则删，少则补，其值随机</span></span><br><span class="line">（<span class="number">17</span>）a.<span class="built_in">resize</span>(<span class="number">10</span>,<span class="number">2</span>); <span class="comment">//将a的现有元素个数调至10个，多则删，少则补，其值为2</span></span><br><span class="line">（<span class="number">18</span>）a.<span class="built_in">reserve</span>(<span class="number">100</span>); <span class="comment">//将a的容量（capacity）扩充至100，也就是说现在测试a.capacity();的时候返回值是100.这种操作只有在需要给a添加大量数据的时候才         显得有意义，因为这将避免内存多次容量扩充操作（当a的容量不足时电脑会自动扩容，当然这必然降低性能） </span></span><br><span class="line">（<span class="number">19</span>）a.<span class="built_in">swap</span>(b); <span class="comment">//b为向量，将a中的元素和b中的元素进行整体性交换</span></span><br><span class="line">（<span class="number">20</span>）a==b; <span class="comment">//b为向量，向量的比较操作还有!=,&gt;=,&lt;=,&gt;,&lt;</span></span><br></pre></td></tr></table></figure><h4 id="三、顺序访问vector的几种方式，举例说明如下："><a href="#三、顺序访问vector的几种方式，举例说明如下：" class="headerlink" title="三、顺序访问vector的几种方式，举例说明如下："></a>三、顺序访问vector的几种方式，举例说明如下：</h4><h5 id="（1）向向量a中添加元素"><a href="#（1）向向量a中添加元素" class="headerlink" title="（1）向向量a中添加元素"></a>（1）向向量a中添加元素</h5><p>1、直接添加</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">a.<span class="built_in">push_back</span>(i);</span><br></pre></td></tr></table></figure><p>2、也可以从数组中选择元素向向量中添加</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">6</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; b；</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)</span><br><span class="line">b.<span class="built_in">push_back</span>(a[i]);</span><br></pre></td></tr></table></figure><p>3、也可以从现有向量中选择元素向向量中添加</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">6</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; b;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(a,a+<span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator it=c.<span class="built_in">begin</span>();it&lt;c.<span class="built_in">end</span>();it++)</span><br><span class="line">b.<span class="built_in">push_back</span>(*it);</span><br></pre></td></tr></table></figure><p>4、也可以从文件中读取元素向向量中添加</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">&quot;data.txt&quot;</span>)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i; in&gt;&gt;i)</span><br><span class="line">    a.<span class="built_in">push_back</span>(i);</span><br></pre></td></tr></table></figure><p>5、【误区】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    a[i]=i;</span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F;这种做法以及类似的做法都是错误的。刚开始我也犯过这种错误，后来发现，下标只能用于获取已存在的元素，而现在的a[i]还是空的对象</p><h5 id="（2）从向量中读取元素"><a href="#（2）从向量中读取元素" class="headerlink" title="（2）从向量中读取元素"></a>（2）从向量中读取元素</h5><p>1、通过下标方式读取</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">6</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(a,a+<span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=b.<span class="built_in">size</span>()<span class="number">-1</span>;i++)</span><br><span class="line">    cout&lt;&lt;b[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure><p>2、通过遍历器方式读取</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">6</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(a,a+<span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator it=b.<span class="built_in">begin</span>();it!=b.<span class="built_in">end</span>();it++)</span><br><span class="line">    cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure><h4 id="四、几种重要的算法，使用时需要包含头文件："><a href="#四、几种重要的算法，使用时需要包含头文件：" class="headerlink" title="四、几种重要的算法，使用时需要包含头文件："></a>四、几种重要的算法，使用时需要包含头文件：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">（<span class="number">1</span>）<span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>()); <span class="comment">//对a中的从a.begin()（包括它）到a.end()（不包括它）的元素进行从小到大排列</span></span><br><span class="line">（<span class="number">2</span>）<span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>()); <span class="comment">//对a中的从a.begin()（包括它）到a.end()（不包括它）的元素倒置，但不排列，如a中元素为1,3,2,4,倒置后为4,2,3,1</span></span><br><span class="line">（<span class="number">3</span>）<span class="built_in">copy</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),b.<span class="built_in">begin</span>()+<span class="number">1</span>); <span class="comment">//把a中的从a.begin()（包括它）到a.end()（不包括它）的元素复制到b中，从b.begin()+1的位置（包括它）开        始复制，覆盖掉原有元素</span></span><br><span class="line">（<span class="number">4</span>）<span class="built_in">find</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),<span class="number">10</span>); <span class="comment">//在a中的从a.begin()（包括它）到a.end()（不包括它）的元素中查找10，若存在返回其在向量中的位置</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ string类</title>
      <link href="/2023/04/04/C++string%E7%B1%BB%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/"/>
      <url>/2023/04/04/C++string%E7%B1%BB%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="C-string类基本方法"><a href="#C-string类基本方法" class="headerlink" title="C++string类基本方法"></a>C++string类基本方法</h3><p>1、string(const char *s) ：将 string 对象初始化为 s 指向的字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>2、string(size_type n,char c) ：创建一个包含 n 个元素的 string 对象，其中每个元素都被初始化为字符 c</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>3、string(const string &amp;str) ：将一个 string 对象初始化为 string 对象 str（复制构造函数）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;abcde&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">str2</span><span class="params">(str)</span></span>;</span><br></pre></td></tr></table></figure><p>4、string() ：创建一个默认的 string 对象，长度为 0（默认构造函数）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string str;</span><br></pre></td></tr></table></figure><p>5、使用C语言风格字符串处理string对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;hello!&quot;</span>;</span><br></pre></td></tr></table></figure><p>6、获取string对象的长度，C语言中使用strlen()来获取字符串长度，C++中使用str.size()或str.length().</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;hello!&quot;</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> len1 = str.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> len2 = str.<span class="built_in">length</span>();</span><br></pre></td></tr></table></figure><p>7、将一个 string 对象赋值给另一个 string 对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;hello!&quot;</span>)</span></span>;</span><br><span class="line">string str2;</span><br><span class="line">str2 = str;</span><br></pre></td></tr></table></figure><p>8、string 对象的拼接<br>C 语言中使用 strcat、strncat 函数来进行字符串拼接操作，C++中可以采用以下方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">str1</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">str2</span><span class="params">(<span class="string">&quot;world&quot;</span>)</span></span>;</span><br><span class="line">string str3 = str1 + str2;</span><br></pre></td></tr></table></figure><p>9、使用 +&#x3D; 来在一个 string 对象后面附加一个 string 对象、字符以及 C 风格的字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">str2</span><span class="params">(<span class="string">&quot;world&quot;</span>)</span></span>;</span><br><span class="line">str += str2;</span><br><span class="line">str += <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">str += <span class="string">&quot;abcd&quot;</span>;</span><br></pre></td></tr></table></figure><p>10、string.append() 函数，在string对象后添加一个string对象或c风格字符串。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">str2</span><span class="params">(<span class="string">&quot;world&quot;</span>)</span></span>;</span><br><span class="line">str.<span class="built_in">append</span>(str2);</span><br><span class="line">str.<span class="built_in">append</span>(<span class="string">&quot;abcd&quot;</span>);</span><br></pre></td></tr></table></figure><p>11、string.push_back() 函数来在一个 string 对象后面附加一个字符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line"><span class="type">char</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">str.<span class="built_in">push_back</span>(ch);</span><br></pre></td></tr></table></figure><p>12、对于string对象的比较，可以直接使用关系运算符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">str1</span><span class="params">(<span class="string">&quot;abcd&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">str2</span><span class="params">(<span class="string">&quot;abcd&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span>(str1 == str2)</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>13、string对象的比较也可以使用string.compare() 方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> string&amp;str)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">size_t</span> pos，<span class="type">size_t</span> len，<span class="type">const</span> string&amp;str)</span><span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">size_t</span> pos，<span class="type">size_t</span> len，<span class="type">const</span> string&amp;str, <span class="type">size_t</span> subpos，<span class="type">size_t</span> sublen)</span><span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * s)</span><span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">size_t</span> pos，<span class="type">size_t</span> len，<span class="type">const</span> <span class="type">char</span> * s)</span><span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">size_t</span> pos，<span class="type">size_t</span> len，<span class="type">const</span> <span class="type">char</span> * s，<span class="type">size_t</span> n)</span><span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="function">string <span class="title">str1</span><span class="params">(<span class="string">&quot;hello world&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">str2</span><span class="params">(<span class="string">&quot;hello boy&quot;</span>)</span></span>;</span><br><span class="line">str1.<span class="built_in">compare</span>(<span class="number">6</span>, <span class="number">3</span>, str2, <span class="number">6</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>14、使用 string.substr() 函数来获取子串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">string str2 = str.<span class="built_in">substr</span>(<span class="number">3</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>15、访问 string 字符串的元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; str[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; str.<span class="built_in">at</span>(<span class="number">2</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>16、使用 string.find() 方法查找字符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  从字符串的 pos 位置开始（若不指定 pos 的值，则默认从索引 0 处开始），查找子字符串 str。</span></span><br><span class="line"><span class="comment">//  如果找到，则返回该子字符串首次出现时其首字符的索引；否则，返回 string::npos：</span></span><br><span class="line"><span class="comment">//  string 类将 npos 定义为保证大于任何有效下标的值。</span></span><br><span class="line"><span class="function">size_type <span class="title">find</span> <span class="params">(<span class="type">const</span> string&amp; str, size_type pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">size_type <span class="title">find</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *s, size_type pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function">size_type <span class="title">find</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *s, size_type pos, size_type n)</span></span>;</span><br><span class="line"><span class="function">size_type <span class="title">find</span> <span class="params">(<span class="type">char</span> ch, size_type pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>17、string.rfind() 与 string.find() 方法类似，只是查找顺序不一样， string.rfind() 是从指定位置 pos （默认为字符串末尾）开始向前查找，直到字符串的首部，并返回第一次查找到匹配项时匹配项首字符的索引。换句话说，就是查找子字符串或字符最后一次出现的位置。</p><p>18、string.find_first_of() 方法在字符串中从指定位置开始向后（默认为索引 0 处）查找参数中任何一个字符首次出现的位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;hello world&quot;</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> pos = str.<span class="built_in">find_first_of</span>(<span class="string">&quot;abcde&quot;</span>);</span><br><span class="line"><span class="type">int</span> pos = str.<span class="built_in">find_first_of</span>(<span class="string">&quot;abcde&quot;</span>, <span class="number">1</span>);  <span class="comment">// 第二个参数为位置</span></span><br></pre></td></tr></table></figure><p>19、string.find_last_of() 方法在字符串中查找参数中任何一个字符最后一次出现的位置</p><p>20、string.find_first_not_of() 方法在字符串中查找第一个不包含在参数中的字符</p><p>21、string.find_last_not_of() 方法在字符串中查找最后一个不包含在参数中的字符</p><p>22、使用 string.insert() 进行插入操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">string&amp; insert（<span class="type">size_t</span> pos，<span class="type">const</span> string＆str）;　　　</span><br><span class="line"><span class="comment">// 在位置 pos 处插入字符串 str</span></span><br><span class="line"></span><br><span class="line">string&amp; insert（<span class="type">size_t</span> pos，<span class="type">const</span> string＆str，<span class="type">size_t</span> subpos，<span class="type">size_t</span> sublen）;　</span><br><span class="line"><span class="comment">// 在位置 pos 处插入字符串 str 的从位置 subpos 处开始的 sublen 个字符</span></span><br><span class="line"></span><br><span class="line">string&amp; insert（<span class="type">size_t</span> pos，<span class="type">const</span> <span class="type">char</span> * s）;　　　　</span><br><span class="line"><span class="comment">// 在位置 pos 处插入字符串 s</span></span><br><span class="line"></span><br><span class="line">string&amp; insert（<span class="type">size_t</span> pos，<span class="type">const</span> <span class="type">char</span> * s，<span class="type">size_t</span> n）;　</span><br><span class="line"><span class="comment">// 在位置 pos 处插入字符串 s 的前 n 个字符</span></span><br><span class="line"></span><br><span class="line">string&amp; insert（<span class="type">size_t</span> pos，<span class="type">size_t</span> n，<span class="type">char</span> c）;　　　　　 </span><br><span class="line"><span class="comment">// 在位置 pos 处插入 n 个字符 c</span></span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">(const_iterator p, <span class="type">size_t</span> n, <span class="type">char</span> c)</span></span>;　</span><br><span class="line"><span class="comment">// 在 p 处插入 n 个字符 c，并返回插入后迭代器的位置</span></span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">(const_iterator p, <span class="type">char</span> c)</span></span>;　　　　　　 </span><br><span class="line"><span class="comment">// 在 p 处插入字符 c，并返回插入后迭代器的位置</span></span><br></pre></td></tr></table></figure><p>23、使用 string.erase() 进行元素删除操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string&amp; <span class="title">erase</span> <span class="params">(<span class="type">size_t</span> pos = <span class="number">0</span>, <span class="type">size_t</span> len = npos)</span></span>;　　　<span class="comment">// 删除从 pos 处开始的 n 个字符</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span> <span class="params">(const_iterator p)</span></span>;　　　　　　　　　　　　<span class="comment">// 删除 p 处的一个字符，并返回删除后迭代器的位置</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span> <span class="params">(const_iterator first, const_iterator last)</span></span>;　<span class="comment">// 删除从 first 到last 之间的字符，并返回删除后迭代器的位置</span></span><br></pre></td></tr></table></figure><p>24、使用 getline() 函数来获取 string 输入</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str;</span><br><span class="line"><span class="built_in">getline</span>(cin, str);</span><br></pre></td></tr></table></figure><p>25、使用 string.empty() 函数判断字符串是否为空</p><p>26、使用 string.swap() 函数交换两个字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string str1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">string str2 = <span class="string">&quot;HELLO&quot;</span>;</span><br><span class="line">str1.<span class="built_in">swap</span>(str2);</span><br></pre></td></tr></table></figure><p>27、string.back()获取或修改字符串最后一个字符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;abcd&quot;</span>)</span></span>;</span><br><span class="line"><span class="type">char</span> b = str.<span class="built_in">back</span>();</span><br><span class="line">str.<span class="built_in">back</span>() = <span class="string">&#x27;e&#x27;</span>;</span><br></pre></td></tr></table></figure><p>28、string.front()获取或修改字符串第一个字符</p><p>29、string.pop_back()删除字符串最后一个元素</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希表 map</title>
      <link href="/2023/04/04/map%E6%9C%89%E5%BA%8F%E5%93%88%E5%B8%8C%E8%A1%A8%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
      <url>/2023/04/04/map%E6%9C%89%E5%BA%8F%E5%93%88%E5%B8%8C%E8%A1%A8%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="一、-map的特性"><a href="#一、-map的特性" class="headerlink" title="一、 map的特性"></a>一、 map的特性</h3><p>所有元素都会根据元素的减值自动被排序。<br>map的所有元素都是pair，同时拥有实值(value)和键值(key)。<br>pair的第一个元素会被视为键值，第二个元素会被视为实值。<br>map不允许两个元素拥有相同的键值。<br><strong>头文件：#include&lt; map &gt;</strong></p><h3 id="二、map的基本构造函数类型"><a href="#二、map的基本构造函数类型" class="headerlink" title="二、map的基本构造函数类型"></a>二、map的基本构造函数类型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string , <span class="type">int</span> &gt;strMap;</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span> ,string &gt;intMap;</span><br><span class="line"></span><br><span class="line">map&lt;sring, <span class="type">char</span>&gt;strMap;</span><br><span class="line"></span><br><span class="line">map&lt; <span class="type">char</span> ,string&gt;charMap;</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">char</span> ,<span class="type">int</span>&gt;charMap;</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span> ,<span class="type">char</span> &gt;intMap；</span><br></pre></td></tr></table></figure><h3 id="三、map的基本操作函数："><a href="#三、map的基本操作函数：" class="headerlink" title="三、map的基本操作函数："></a>三、map的基本操作函数：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">begin</span>()     <span class="comment">//返回指向map头部的迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">clear</span>()    <span class="comment">//删除所有元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">count</span>()     <span class="comment">//返回指定元素出现的次数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">empty</span>()     <span class="comment">//如果map为空则返回true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">end</span>()      <span class="comment">//返回指向map末尾的迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">equal_range</span>()  <span class="comment">//返回特殊条目的迭代器对</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">erase</span>()     <span class="comment">//删除一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">find</span>()      <span class="comment">//查找一个元素。查的是 健</span></span><br><span class="line"><span class="comment">//当所查找的关键key出现时，它返回数据所在对象的位置，如果沒有，返回iter与end()函数的值相同。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">get_allocator</span>() <span class="comment">//返回map的配置器</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">insert</span>()     <span class="comment">//插入元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">key_comp</span>()    <span class="comment">//返回比较元素key的函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">lower_bound</span>()  <span class="comment">//返回键值&gt;=给定元素的第一个位置</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">max_size</span>()    <span class="comment">//返回可以容纳的最大元素个数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">rbegin</span>()     <span class="comment">//返回一个指向map尾部的逆向迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">rend</span>()      <span class="comment">//返回一个指向map头部的逆向迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">size</span>()      <span class="comment">//返回map中元素的个数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">swap</span>()      <span class="comment">//交换两个map</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">upper_bound</span>()   <span class="comment">//返回键值&gt;给定元素的第一个位置</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">value_comp</span>()   <span class="comment">//返回比较元素value的函数</span></span><br></pre></td></tr></table></figure><h3 id="四、map添加数据"><a href="#四、map添加数据" class="headerlink" title="四、map添加数据"></a>四、map添加数据</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span> ,string&gt; maplive;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>,string&gt; <span class="title">value</span><span class="params">(<span class="number">1</span>,<span class="string">&quot;a&quot;</span>)</span>；maplive.<span class="title">insert</span><span class="params">(value)</span></span>;</span><br><span class="line"><span class="comment">//等价于maplive.insert(pair&lt;int,string&gt;(1,&quot;a&quot;));</span></span><br><span class="line"></span><br><span class="line">maplive.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>,string&gt;::<span class="built_in">value_type</span>(<span class="number">1</span>,<span class="string">&quot;a&quot;</span>));</span><br><span class="line"></span><br><span class="line">maplive[<span class="number">1</span>]=<span class="string">&quot;a&quot;</span>;<span class="comment">//map中最简单最常用的插入添加！</span></span><br></pre></td></tr></table></figure><h3 id="五、pair用法"><a href="#五、pair用法" class="headerlink" title="五、pair用法"></a>五、pair用法</h3><p><strong>头文件：#include&lt; utility &gt;</strong></p><h4 id="1-pair-默认对first升序，当first相同时对second升序；"><a href="#1-pair-默认对first升序，当first相同时对second升序；" class="headerlink" title="1.pair 默认对first升序，当first相同时对second升序；"></a>1.pair 默认对first升序，当first相同时对second升序；</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类模板：<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt; <span class="keyword">struct</span> <span class="title class_">pair</span></span><br></pre></td></tr></table></figure><p>参数：T1是第一个值的数据类型，T2是第二个值的数据类型。</p><p>功能：pair将一对值组合成一个值，这一对值可以具有不同的数据类型（T1和T2），两个值可以分别用pair的两个公有函数first和second访问。<br>pair实际上可以看作一个内部有两个元素的结构体,且这两个元素的类型是可以指定的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">pair</span>&#123;</span><br><span class="line">    typename1 first;</span><br><span class="line">    typename2 second;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-定义（构造）："><a href="#2-定义（构造）：" class="headerlink" title="2.定义（构造）："></a>2.定义（构造）：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; p1;     <span class="comment">//使用默认构造函数</span></span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; <span class="title">p2</span><span class="params">(<span class="number">1</span>, <span class="number">2.4</span>)</span></span>;  <span class="comment">//用给定值初始化</span></span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; <span class="title">p3</span><span class="params">(p2)</span></span>;  <span class="comment">//拷贝构造函数</span></span><br></pre></td></tr></table></figure><h5 id="1-访问两个元素（通过first和second）："><a href="#1-访问两个元素（通过first和second）：" class="headerlink" title="1.访问两个元素（通过first和second）："></a>1.访问两个元素（通过first和second）：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; p1;  <span class="comment">//使用默认构造函数</span></span><br><span class="line">p1.first = <span class="number">1</span>;</span><br><span class="line">p1.second = <span class="number">2.5</span>;</span><br><span class="line">cout &lt;&lt; p1.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p1.second &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h5 id="2-赋值-："><a href="#2-赋值-：" class="headerlink" title="2.赋值 ："></a>2.赋值 ：</h5><p>&#x2F;&#x2F;（1）利用make_pair：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; p1;</span><br><span class="line">p1 = <span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">1.2</span>);</span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F;（2）变量间赋值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; <span class="title">p1</span><span class="params">(<span class="number">1</span>, <span class="number">1.2</span>)</span></span>;</span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt; p2 = p1;</span><br></pre></td></tr></table></figure><h5 id="3-示例"><a href="#3-示例" class="headerlink" title="3.示例"></a>3.示例</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem(x,y) memset(x,y,sizeof(x))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;pa[<span class="number">100</span>];<span class="comment">//定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;a,pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.first!=b.first)</span><br><span class="line">      <span class="keyword">return</span> a.first&gt;b.first;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">      <span class="keyword">return</span> a.second&lt;b.second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        pa[i]=<span class="built_in">make_pair</span>(a,b);<span class="comment">//赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(pa,pa+<span class="number">5</span>,cmp);<span class="comment">//排序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,pa[i].first,pa[i].second);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六、map示例"><a href="#六、map示例" class="headerlink" title="六、map示例"></a>六、map示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    map&lt;string,<span class="type">int</span>&gt; strMap;  <span class="comment">//以string为键值，以int为实值</span></span><br><span class="line">    strMap[<span class="built_in">string</span>(<span class="string">&quot;jjhou&quot;</span>)] = <span class="number">1</span>;</span><br><span class="line">    strMap[<span class="built_in">string</span>(<span class="string">&quot;jerry&quot;</span>)] = <span class="number">2</span>;</span><br><span class="line">    strMap[<span class="built_in">string</span>(<span class="string">&quot;jason&quot;</span>)] = <span class="number">3</span>;</span><br><span class="line">    strMap[<span class="built_in">string</span>(<span class="string">&quot;jimmy&quot;</span>)] = <span class="number">4</span>;</span><br><span class="line"><span class="function">pair&lt;string,<span class="type">int</span>&gt; <span class="title">value</span><span class="params">(string(<span class="string">&quot;david&quot;</span>),<span class="number">5</span>)</span></span>;</span><br><span class="line">    strMap.<span class="built_in">insert</span>(value);<span class="comment">//插入新元素</span></span><br><span class="line">    <span class="comment">//或 strMap[健]=键值；</span></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line">    map&lt;string,<span class="type">int</span>&gt;::iterator iter = strMap.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span>(;iter !=strMap.<span class="built_in">end</span>();iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;iter-&gt;second&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> number = strMap[<span class="built_in">string</span>(<span class="string">&quot;jjhou&quot;</span>)];</span><br><span class="line">    cout&lt;&lt;number&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"><span class="comment">//查找元素</span></span><br><span class="line">    map&lt;string,<span class="type">int</span>&gt;::iterator iter3;</span><br><span class="line">    <span class="comment">//面对关联式容器，应该使用其所提供的find函数来搜索元素，会比使用STL算法find()更有效率。因为STL算法find()只是循环搜索。</span></span><br><span class="line">    iter3 = strMap.<span class="built_in">find</span>(<span class="built_in">string</span>(<span class="string">&quot;mchen&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span>(iter3 == strMap.<span class="built_in">end</span>())</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;mchen no fount&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    iter3 = strMap.<span class="built_in">find</span>(<span class="built_in">string</span>(<span class="string">&quot;jerry&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span>(iter3 != strMap.<span class="built_in">end</span>())</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;jerry fount&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//修改实值，键值不可修改</span></span><br><span class="line">    iter3-&gt;second = <span class="number">9</span>; <span class="comment">//可以通过map迭代器修改“value”(not key)</span></span><br><span class="line">    <span class="type">int</span> number1 = strMap[<span class="built_in">string</span>(<span class="string">&quot;jerry&quot;</span>)];</span><br><span class="line">    cout&lt;&lt;number1&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    map&lt;string,<span class="type">int</span>&gt;::iterator iter1 = strMap.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span>(;iter1 !=strMap.<span class="built_in">end</span>();iter1++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;iter1-&gt;first&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;iter1-&gt;second&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//删除元素</span></span><br><span class="line">    strMap.<span class="built_in">erase</span>(iter1);<span class="comment">//删除一个条目</span></span><br><span class="line">    strMap.<span class="built_in">erase</span>(<span class="built_in">string</span>(<span class="string">&quot;jason&quot;</span>));<span class="comment">//根据键值删除</span></span><br><span class="line"></span><br><span class="line">    map&lt;string,<span class="type">int</span>&gt;::iterator iter2 = strMap.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span>(;iter2 !=strMap.<span class="built_in">end</span>();iter2++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;iter2-&gt;first&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;iter2-&gt;second&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="七、map中insert用法"><a href="#七、map中insert用法" class="headerlink" title="七、map中insert用法"></a>七、map中insert用法</h3><h4 id="1-用insert函数插入pair数据"><a href="#1-用insert函数插入pair数据" class="headerlink" title="1.用insert函数插入pair数据"></a>1.用insert函数插入pair数据</h4><h5 id="第一种：用insert函数插入pair数据：在VC下请加入这条语句，屏蔽4786警告-＃pragma-warning-disable-4786"><a href="#第一种：用insert函数插入pair数据：在VC下请加入这条语句，屏蔽4786警告-＃pragma-warning-disable-4786" class="headerlink" title="第一种：用insert函数插入pair数据：在VC下请加入这条语句，屏蔽4786警告 ＃pragma warning (disable:4786) )"></a>第一种：用insert函数插入pair数据：在VC下请加入这条语句，屏蔽4786警告 ＃pragma warning (disable:4786) )</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, string&gt; mapStudent;</span><br><span class="line"></span><br><span class="line">mapStudent.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">1</span>, <span class="string">&quot;student_one&quot;</span>));</span><br><span class="line"></span><br><span class="line">mapStudent.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">2</span>, <span class="string">&quot;student_two&quot;</span>));</span><br><span class="line"></span><br><span class="line">mapStudent.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">3</span>, <span class="string">&quot;student_three&quot;</span>));</span><br></pre></td></tr></table></figure><h5 id="第二种：用insert函数插入value-type数据，下面举例说明"><a href="#第二种：用insert函数插入value-type数据，下面举例说明" class="headerlink" title="第二种：用insert函数插入value_type数据，下面举例说明"></a>第二种：用insert函数插入value_type数据，下面举例说明</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, string&gt; mapStudent;</span><br><span class="line"></span><br><span class="line">mapStudent.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>, string&gt;::<span class="built_in">value_type</span> (<span class="number">1</span>, <span class="string">&quot;student_one&quot;</span>));</span><br><span class="line"></span><br><span class="line">mapStudent.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>, string&gt;::<span class="built_in">value_type</span> (<span class="number">2</span>, <span class="string">&quot;student_two&quot;</span>));</span><br><span class="line"></span><br><span class="line">mapStudent.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>, string&gt;::<span class="built_in">value_type</span> (<span class="number">3</span>, <span class="string">&quot;student_three&quot;</span>));</span><br></pre></td></tr></table></figure><h5 id="第三种：在insert函数中使用make-pair-函数，下面举例说明"><a href="#第三种：在insert函数中使用make-pair-函数，下面举例说明" class="headerlink" title="第三种：在insert函数中使用make_pair()函数，下面举例说明"></a>第三种：在insert函数中使用make_pair()函数，下面举例说明</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, string&gt; mapStudent;</span><br><span class="line"></span><br><span class="line">mapStudent.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="string">&quot;student_one&quot;</span>));</span><br><span class="line"></span><br><span class="line">mapStudent.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="string">&quot;student_two&quot;</span>));</span><br><span class="line"></span><br><span class="line">mapStudent.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="string">&quot;student_three&quot;</span>));</span><br></pre></td></tr></table></figure><h5 id="第四种：用数组方式插入数据，下面举例说明"><a href="#第四种：用数组方式插入数据，下面举例说明" class="headerlink" title="第四种：用数组方式插入数据，下面举例说明"></a>第四种：用数组方式插入数据，下面举例说明</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, string&gt; mapStudent;</span><br><span class="line"></span><br><span class="line">mapStudent[<span class="number">1</span>] = <span class="string">&quot;student_one&quot;</span>;</span><br><span class="line"></span><br><span class="line">mapStudent[<span class="number">2</span>] = <span class="string">&quot;student_two&quot;</span>;</span><br><span class="line"></span><br><span class="line">mapStudent[<span class="number">3</span>] = <span class="string">&quot;student_three&quot;</span>;</span><br></pre></td></tr></table></figure><h4 id="2-示例"><a href="#2-示例" class="headerlink" title="2.示例"></a>2.示例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>, string&gt; mapStudent;</span><br><span class="line">    mapStudent.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">1</span>, <span class="string">&quot;student_one&quot;</span>));</span><br><span class="line">    mapStudent.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">2</span>, <span class="string">&quot;student_two&quot;</span>));</span><br><span class="line">    mapStudent.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">3</span>, <span class="string">&quot;student_three&quot;</span>));</span><br><span class="line">    <span class="comment">//声明了一个key为int类型，value为string类型的map，</span></span><br><span class="line">    <span class="comment">//用insert函数插入value_type数据，</span></span><br><span class="line">    <span class="comment">//插入前，需要将(1,&quot;student_one&quot;)转换为map&lt;int,string&gt;::value_type数据再插入。</span></span><br><span class="line"></span><br><span class="line">    map&lt;<span class="type">int</span>, string&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter = mapStudent.<span class="built_in">begin</span>(); iter != mapStudent.<span class="built_in">end</span>(); iter++)&#123;</span><br><span class="line">       cout&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;iter-&gt;second&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希表 unordered_map</title>
      <link href="/2023/04/04/unordered_map%E6%97%A0%E5%BA%8F%E5%93%88%E5%B8%8C%E8%A1%A8%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
      <url>/2023/04/04/unordered_map%E6%97%A0%E5%BA%8F%E5%93%88%E5%B8%8C%E8%A1%A8%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="1-插入元素"><a href="#1-插入元素" class="headerlink" title="1.插入元素"></a>1.插入元素</h3><p>map中插入元素的方法有如下集中</p><h4 id="1-1-直接用-符"><a href="#1-1-直接用-符" class="headerlink" title="1.1 直接用[]符"></a>1.1 直接用[]符</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, string&gt; mymap;</span><br><span class="line">mymap[<span class="number">1</span>] = <span class="string">&quot;a&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>map的源码中重载了[]操作符</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">map&lt;_Key, _Tp, _Compare, _Allocator&gt;::<span class="keyword">operator</span>[](key_type&amp;&amp; __k)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> __tree_.__emplace_unique_key_args(__k,</span><br><span class="line">        _VSTD::piecewise_construct,</span><br><span class="line">        _VSTD::forward_as_tuple(_VSTD::<span class="built_in">move</span>(__k)),</span><br><span class="line">        _VSTD::forward_as_tuple()).first-&gt;__get_value().second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而且从上面代码不难看出，[]操作，先是move掉了map中原有的数据，再将新数据放进去，所以用[]操作的话，可以改变map中已有的key对应的value。</p><h4 id="1-2-make-pair"><a href="#1-2-make-pair" class="headerlink" title="1.2 make_pair"></a>1.2 make_pair</h4><p>make_pair是比较方便的方法，该方法可以根据传入的两个参数，直接构造成一个pari对象，insert到map中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mymap.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="string">&quot;c&quot;</span>));</span><br></pre></td></tr></table></figure><h4 id="1-3-pair"><a href="#1-3-pair" class="headerlink" title="1.3 pair"></a>1.3 pair</h4><p>可以使用pari方法插入kv对。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mymap.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">4</span>, <span class="string">&quot;d&quot;</span>));</span><br></pre></td></tr></table></figure><h4 id="1-4-value-type"><a href="#1-4-value-type" class="headerlink" title="1.4 value_type"></a>1.4 value_type</h4><p>为了避免隐式转换，可以使用value_type来传递类型，value_type是容器中本身提供的型别定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mymap.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>, string&gt;::<span class="built_in">value_type</span>(<span class="number">2</span>, <span class="string">&quot;b&quot;</span>));</span><br></pre></td></tr></table></figure><p>需要注意的一点是，所有insert方式，如果插入的key值在map中原来存在，都不能改变其原来对应的值。</p><h3 id="2-判断元素是否存在"><a href="#2-判断元素是否存在" class="headerlink" title="2.判断元素是否存在"></a>2.判断元素是否存在</h3><h4 id="2-1-find方法"><a href="#2-1-find方法" class="headerlink" title="2.1 find方法"></a>2.1 find方法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> one_in_map = mymap.<span class="built_in">find</span>(<span class="number">1</span>) != mymap.<span class="built_in">end</span>()? <span class="literal">true</span>:<span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>如果key在map中，find方法会返回key对应的迭代器。如果key不存在，find会返回end。</p><h4 id="2-2-count方法"><a href="#2-2-count方法" class="headerlink" title="2.2 count方法"></a>2.2 count方法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> five_in_map = mymap.<span class="built_in">count</span>(<span class="number">5</span>) &gt; <span class="number">0</span>? <span class="literal">true</span>: <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>count方法可以统计key在map中出现的次数。对于map来书，key不能重复，因此count方法返回值为1或者0。</p><h3 id="3-获取key对应的值"><a href="#3-获取key对应的值" class="headerlink" title="3.获取key对应的值"></a>3.获取key对应的值</h3><h4 id="3-1-find方法"><a href="#3-1-find方法" class="headerlink" title="3.1 find方法"></a>3.1 find方法</h4><p>前面我们已经提到了find方法可以找到key对应的迭代器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string one_value = mymap.<span class="built_in">find</span>(<span class="number">1</span>)-&gt;second;</span><br></pre></td></tr></table></figure><h4 id="3-2-at方法"><a href="#3-2-at方法" class="headerlink" title="3.2 at方法"></a>3.2 at方法</h4><p>at方法可以直接返回key对应的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string two_value = mymap.<span class="built_in">at</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h4 id="3-3-操作符"><a href="#3-3-操作符" class="headerlink" title="3.3 []操作符"></a>3.3 []操作符</h4><p>[]也可以直接获取key对应的值。不过需要注意的是，如果key不在map中，[]这种方式会将key插入map中，而前面的find方法，at方法， 都会报异常。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string six_value = mymap[<span class="number">6</span>];</span><br></pre></td></tr></table></figure><h3 id="4-删除元素"><a href="#4-删除元素" class="headerlink" title="4.删除元素"></a>4.删除元素</h3><p>erase方法可以删除map中的元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mymap.<span class="built_in">erase</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>注意删除元素的时候，当删除迭代器所指向的对象时，迭代器可能会失效。</p><pre><code>for(iter=mymap.begin(); iter!=mymap.end(); iter++) &#123;    mymap.erase(iter);&#125;</code></pre><p>上述代码在运行的时候就会报错，在我自己机器上测试的时候会有如下错误</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libc++abi.dylib: terminating with uncaught exception of type std::bad_alloc: std::bad_alloc</span><br></pre></td></tr></table></figure><p>对iter直线的元素进行erase时，会使得iter不再成为一个有效的迭代器，如果此后未对iter重新设值就使用iter，会出现异常。iter++就能导致一个未定义行为。<br>如果我们要在迭代器中删除元素，可以按照如下方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(iter=mymap.<span class="built_in">begin</span>(); iter!=mymap.<span class="built_in">end</span>();) &#123;</span><br><span class="line">    <span class="keyword">if</span> (iter-&gt;second==<span class="string">&quot;c&quot;</span>) &#123;</span><br><span class="line">        mymap.<span class="built_in">erase</span>(iter++);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        iter++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-遍历map"><a href="#5-遍历map" class="headerlink" title="5.遍历map"></a>5.遍历map</h3><p>遍历容器是最常见的需求，一般可以通过下面两种方式来遍历。</p><h4 id="5-1-通过迭代器"><a href="#5-1-通过迭代器" class="headerlink" title="5.1 通过迭代器"></a>5.1 通过迭代器</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, string&gt;::iterator iter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(iter=mymap.<span class="built_in">begin</span>(); iter!=mymap.<span class="built_in">end</span>(); iter++) &#123;</span><br><span class="line">    cout&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">&quot;: &quot;</span>&lt;&lt;iter-&gt;second&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-auto关键字"><a href="#5-2-auto关键字" class="headerlink" title="5.2 auto关键字"></a>5.2 auto关键字</h4><p>上面的iter类型比较复杂，我们可以偷懒使用auto关键字，让编译器自动推断类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> node: mymap) &#123;</span><br><span class="line">    cout&lt;&lt;node.first&lt;&lt;<span class="string">&quot;: &quot;</span>&lt;&lt;node.second&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-unordered-map用法"><a href="#6-unordered-map用法" class="headerlink" title="6.unordered_map用法"></a>6.unordered_map用法</h3><p>unordered_map与map的用法基本一直，最大的区别在于：<br>map的key是有序的，而unordered_map的key为无序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>, string&gt; commap;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, string&gt; umap;</span><br><span class="line">    commap[<span class="number">1</span>]=<span class="string">&quot;a&quot;</span>; commap[<span class="number">3</span>]=<span class="string">&quot;c&quot;</span>; commap[<span class="number">2</span>]=<span class="string">&quot;b&quot;</span>; commap[<span class="number">4</span>]=<span class="string">&quot;d&quot;</span>;</span><br><span class="line">    umap[<span class="number">1</span>]=<span class="string">&quot;aa&quot;</span>; umap[<span class="number">3</span>]=<span class="string">&quot;cc&quot;</span>; umap[<span class="number">4</span>]=<span class="string">&quot;dd&quot;</span>; umap[<span class="number">2</span>]=<span class="string">&quot;bb&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> node: commap) &#123;</span><br><span class="line">        cout&lt;&lt;node.first&lt;&lt;<span class="string">&quot;: &quot;</span>&lt;&lt;node.second&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> node: umap) &#123;</span><br><span class="line">        cout&lt;&lt;node.first&lt;&lt;<span class="string">&quot;: &quot;</span>&lt;&lt;node.second&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>: b</span><br><span class="line"><span class="number">3</span>: c</span><br><span class="line"><span class="number">4</span>: d</span><br><span class="line"><span class="number">2</span>: bb</span><br><span class="line"><span class="number">4</span>: dd</span><br><span class="line"><span class="number">3</span>: cc</span><br><span class="line"><span class="number">1</span>: aa</span><br></pre></td></tr></table></figure><p>对比map与unordered_map，两者的区别如下：<br>实现方式：unordered_map为哈希表，map为红黑树。<br>查找操作：unordered_map 平均为O(1)，最差为O(n), map为log(n)。<br>插入，删除操作：unordered_map与查找一样，map为log(n)+平衡二叉树所用的时间。<br>适用场景：unordered_map适用查找频率高，而map适合要求key有序的场景。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>, string&gt; commap;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, string&gt; umap;</span><br><span class="line">    commap[<span class="number">1</span>]=<span class="string">&quot;a&quot;</span>; commap[<span class="number">3</span>]=<span class="string">&quot;c&quot;</span>; commap[<span class="number">2</span>]=<span class="string">&quot;b&quot;</span>; commap[<span class="number">4</span>]=<span class="string">&quot;d&quot;</span>;</span><br><span class="line">    umap[<span class="number">1</span>]=<span class="string">&quot;aa&quot;</span>; umap[<span class="number">3</span>]=<span class="string">&quot;cc&quot;</span>; umap[<span class="number">4</span>]=<span class="string">&quot;dd&quot;</span>; umap[<span class="number">2</span>]=<span class="string">&quot;bb&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> node: commap) &#123;</span><br><span class="line">        cout&lt;&lt;node.first&lt;&lt;<span class="string">&quot;: &quot;</span>&lt;&lt;node.second&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> node: umap) &#123;</span><br><span class="line">        cout&lt;&lt;node.first&lt;&lt;<span class="string">&quot;: &quot;</span>&lt;&lt;node.second&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: a</span><br><span class="line"><span class="number">2</span>: b</span><br><span class="line"><span class="number">3</span>: c</span><br><span class="line"><span class="number">4</span>: d</span><br><span class="line"><span class="number">2</span>: bb</span><br><span class="line"><span class="number">4</span>: dd</span><br><span class="line"><span class="number">3</span>: cc</span><br><span class="line"><span class="number">1</span>: aa</span><br></pre></td></tr></table></figure><h3 id="7-map自定义key排序规则"><a href="#7-map自定义key排序规则" class="headerlink" title="7.map自定义key排序规则"></a>7.map自定义key排序规则</h3><p>map的key，默认是按照升序排列的，可以参考一下其中源码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Key</span>, <span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Compare</span> = less&lt;_Key&gt;,</span><br><span class="line">          <span class="keyword">class</span> _Allocator = allocator&lt;pair&lt;<span class="type">const</span> _Key, _Tp&gt; &gt; &gt;</span><br><span class="line"><span class="keyword">class</span> _LIBCPP_TEMPLATE_VIS map</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>其中less的签名为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">_LIBCPP_TEMPLATE_VIS</span> less : binary_function&lt;_Tp, _Tp, <span class="type">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY</span></span><br><span class="line"><span class="function">    <span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> _Tp&amp; __x, <span class="type">const</span> _Tp&amp; __y)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;<span class="keyword">return</span> __x &lt; __y;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据上述代码不难看出，less是一个结构体，重载了()操作符，是一个函数对象，默认升序排列。</p><p>如果我们想让map按key降序排列，可以这样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>, greater&lt;string&gt;&gt; map1;</span><br></pre></td></tr></table></figure><p>其中greater与less就是对应的，表示降序。</p><p>如果想自定义排序规则，也是可以的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map&lt;string, <span class="type">int</span>, greater&lt;string&gt;&gt; map1;</span><br><span class="line">    map1[<span class="string">&quot;a&quot;</span>]=<span class="number">1</span>; map1[<span class="string">&quot;b&quot;</span>]=<span class="number">2</span>; map1[<span class="string">&quot;c&quot;</span>]=<span class="number">3</span>; map1[<span class="string">&quot;d&quot;</span>]=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> node: map1) &#123;</span><br><span class="line">        cout&lt;&lt;node.first&lt;&lt;<span class="string">&quot;: &quot;</span>&lt;&lt;node.second&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    map&lt;string, <span class="type">int</span>, myCompare&gt; map2;</span><br><span class="line">    map2[<span class="string">&quot;bbbb&quot;</span>]=<span class="number">1</span>; map2[<span class="string">&quot;ccc&quot;</span>]=<span class="number">2</span>; map2[<span class="string">&quot;a&quot;</span>]=<span class="number">3</span>; map2[<span class="string">&quot;dd&quot;</span>]=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> node: map2) &#123;</span><br><span class="line">        cout&lt;&lt;node.first&lt;&lt;<span class="string">&quot;: &quot;</span>&lt;&lt;node.second&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f3</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">d: <span class="number">4</span></span><br><span class="line">c: <span class="number">3</span></span><br><span class="line">b: <span class="number">2</span></span><br><span class="line">a: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">bbbb: <span class="number">1</span></span><br><span class="line">ccc: <span class="number">2</span></span><br><span class="line">dd: <span class="number">4</span></span><br><span class="line">a: <span class="number">3</span></span><br></pre></td></tr></table></figure><p>我们重写了一个类似less结构体，重载()操作符，就可以实现自己的排序规则。</p><h3 id="8-map按value排序"><a href="#8-map按value排序" class="headerlink" title="8.map按value排序"></a>8.map按value排序</h3><p>如果我们想要对map按照value排序，可以利用stl库中的sort方法。我们可以将map中的元素先拷贝到vector中，再对vector进行排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">mycompare_func</span><span class="params">(<span class="type">const</span> pair&lt;string, <span class="type">int</span>&gt; &amp;a, <span class="type">const</span> pair&lt;string, <span class="type">int</span>&gt; &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.second==b.second) <span class="keyword">return</span> a.first&gt;b.first;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.second&gt;b.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map&lt;std::string, <span class="type">int</span>&gt; mymap&#123;&#123;<span class="string">&quot;b&quot;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&quot;d&quot;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&quot;c&quot;</span>, <span class="number">3</span>&#125;, &#123;<span class="string">&quot;a&quot;</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line">    vector&lt;pair&lt;std::string, <span class="type">int</span>&gt;&gt; <span class="built_in">v</span>(mymap.<span class="built_in">begin</span>(), mymap.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), mycompare_func);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> node: v) &#123;</span><br><span class="line">        cout&lt;&lt;node.first&lt;&lt;<span class="string">&quot;: &quot;</span>&lt;&lt;node.second&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f4</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后代码输出结果为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a: <span class="number">4</span></span><br><span class="line">c: <span class="number">3</span></span><br><span class="line">d: <span class="number">2</span></span><br><span class="line">b: <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀和与差分</title>
      <link href="/2023/04/04/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"/>
      <url>/2023/04/04/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h3 id="一、前缀和"><a href="#一、前缀和" class="headerlink" title="一、前缀和"></a>一、前缀和</h3><h4 id="1、前缀和"><a href="#1、前缀和" class="headerlink" title="1、前缀和"></a>1、前缀和</h4><p>前缀和是指某序列的前n项和，可以把它理解为数学上的数列的前n项和，而差分可以看成前缀和的逆运算。合理的使用前缀和与差分，可以将某些复杂的问题简单化。</p><h4 id="2、前缀和算法有什么好处？"><a href="#2、前缀和算法有什么好处？" class="headerlink" title="2、前缀和算法有什么好处？"></a>2、前缀和算法有什么好处？</h4><p>先来了解这样一个问题：</p><p>输入一个长度为n的整数序列。接下来再输入m个询问，每个询问输入一对l, r。对于每个询问，输出原序列中从第l个数到第r个数的和。</p><p>我们很容易想出暴力解法，遍历区间求和。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= r; i++)</span><br><span class="line">    &#123; </span><br><span class="line">        sum += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span>  <span class="number">12</span>  <span class="number">13</span>  <span class="number">14</span>  <span class="number">15</span>  <span class="number">16</span></span><br></pre></td></tr></table></figure><p>这样的时间复杂度为O(n * m)，如果n和m的数据量稍微大一点就有可能超时，而我们如果使用前缀和的方法来做的话就能够将时间复杂度降到O(n + m)，大大提高了运算效率。</p><p>具体做法：</p><p>首先做一个预处理，定义一个sum[]数组，sum[i]代表a数组中前i个数的和。</p><p>求前缀和运算：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> sum[N], a[N]; <span class="comment">//sum[i]=a[1]+a[2]+a[3].....a[i];</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++)</span><br><span class="line">&#123; </span><br><span class="line">    sum[i] = sum[i - <span class="number">1</span>] + a[i];   </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span></span><br></pre></td></tr></table></figure><p>然后查询操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, sum[r] - sum[l - <span class="number">1</span>]);</span><br><span class="line"><span class="number">1</span>  <span class="number">2</span></span><br></pre></td></tr></table></figure><p>对于每次查询，只需执行sum[r] - sum[l - 1] ，时间复杂度为O(1)</p><p>原理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sum[r] = a[<span class="number">1</span>] + a[<span class="number">2</span>] + a[<span class="number">3</span>] + a[l<span class="number">-1</span>] + a[l] + a[l + <span class="number">1</span>] ...... a[r];</span><br><span class="line">sum[l - <span class="number">1</span>] = a[<span class="number">1</span>] + a[<span class="number">2</span>] + a[<span class="number">3</span>] + a[l - <span class="number">1</span>];</span><br><span class="line">sum[r] - sum[l - <span class="number">1</span>] = a[l] + a[l + <span class="number">1</span>] + ......+ a[r];</span><br></pre></td></tr></table></figure><p>图解</p><p>这样，对于每个询问，只需要执行 sum[r] - sum[l - 1]。输出原序列中从第l个数到第r个数的和的时间复杂度变成了O(1)。</p><p>我们把它叫做一维前缀和。</p><p>总结：</p><p>练习一道题目<br>输入一个长度为n的整数序列。<br>接下来再输入m个询问，每个询问输入一对l, r。<br>对于每个询问，输出原序列中从第l个数到第r个数的和。<br>输入格式<br>第一行包含两个整数n和m。<br>第二行包含n个整数，表示整数数列。<br>接下来m行，每行包含两个整数l和r，表示一个询问的区间范围。<br>输出格式<br>共m行，每行输出一个询问的结果。<br>数据范围<br>1≤l≤r≤n,<br>1≤n,m≤100000,<br>−1000≤数列中元素的值≤1000<br>输入样例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">3</span> <span class="number">6</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p>输出样例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N], s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) s[i] = s[i - <span class="number">1</span>] + a[i]; <span class="comment">// 前缀和的初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, s[r] - s[l - <span class="number">1</span>]); <span class="comment">// 区间和的计算</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span>  <span class="number">12</span>  <span class="number">13</span>  <span class="number">14</span>  <span class="number">15</span>  <span class="number">16</span>  <span class="number">17</span>  <span class="number">18</span>  <span class="number">19</span>  <span class="number">20</span>  <span class="number">21</span>  <span class="number">22</span>  <span class="number">23</span>  <span class="number">24</span>  <span class="number">25</span></span><br></pre></td></tr></table></figure><h4 id="3、二维前缀和"><a href="#3、二维前缀和" class="headerlink" title="3、二维前缀和"></a>3、二维前缀和</h4><p>如果数组变成了二维数组怎么办呢？</p><p>先给出问题：</p><p>输入一个n行m列的整数矩阵，再输入q个询问，每个询问包含四个整数x1, y1, x2, y2，表示一个子矩阵的左上角坐标和右下角坐标。对于每个询问输出子矩阵中所有数的和。</p><p>同一维前缀和一样，我们先来定义一个二维数组s[][] , s[i][j] 表示二维数组中，左上角(1, 1)到右下角(i, j)所包围的矩阵元素的和。接下来推导二维前缀和的公式。</p><p>先看一张图：</p><p>紫色面积是指(1, 1)左上角到(i, j - 1)右下角的矩形面积, 绿色面积是指(1, 1)左上角到(i - 1, j )右下角的矩形面积。每一个颜色的矩形面积都代表了它所包围元素的和。</p><p>从图中我们很容易看出，整个外围蓝色矩形面积s[i][j] &#x3D; 绿色面积s[i - 1][j] + 紫色面积s[i][j - 1] - 重复加的红色的面积s[i - 1][j - 1] + 小方块的面积a[i][j];</p><p>因此得出二维前缀和预处理公式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s[i][j] = s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span> ] + a[i] [j] - s[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>接下来回归问题去求以(x1,y1)为左上角和以(x2,y2)为右下角的矩阵的元素的和。</p><p>如图：</p><p>紫色面积是指 (1, 1)左上角到(x1 - 1, y2)右下角的矩形面积 ，黄色面积是指(1, 1)左上角到(x2, y1 - 1)右下角的矩形面积；</p><p>不难推出：</p><p>绿色矩形的面积 &#x3D; 整个外围面积s[x2, y2] - 黄色面积s[x2, y1 - 1] - 紫色面积s[x1 - 1, y2] + 重复减去的红色面积 s[x1 - 1, y1 - 1]</p><p>因此二维前缀和的结论为：</p><p>以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：<br>s[x2, y2] - s[x1 - 1, y2] - s[x2, y1 - 1] + s[x1 - 1, y1 - 1]</p><p>总结：</p><p>练习一道完整题目：<br>输入一个n行m列的整数矩阵，再输入q个询问，每个询问包含四个整数x1, y1, x2, y2，表示一个子矩阵的左上角坐标和右下角坐标。</p><p>对于每个询问输出子矩阵中所有数的和。</p><p>输入格式<br>第一行包含三个整数n，m，q。</p><p>接下来n行，每行包含m个整数，表示整数矩阵。</p><p>接下来q行，每行包含四个整数x1, y1, x2, y2，表示一组询问。</p><p>输出格式</p><p>共q行，每行输出一个询问的结果。</p><p>数据范围</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>≤n,m≤<span class="number">1000</span>,</span><br><span class="line"><span class="number">1</span>≤q≤<span class="number">200000</span>,</span><br><span class="line"><span class="number">1</span>≤x1≤x2≤n,</span><br><span class="line"><span class="number">1</span>≤y1≤y2≤m,</span><br></pre></td></tr></table></figure><p>−1000≤矩阵内元素的值≤1000<br>1<br>2<br>3<br>4<br>5<br>输入样例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">7</span> <span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">6</span> <span class="number">2</span> <span class="number">8</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure><p>输出样例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line"><span class="type">int</span> s[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i][j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">            s[i][j] += s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (q -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s[x2][y2] - s[x1 - <span class="number">1</span>][y2] - s[x2][y1 - <span class="number">1</span>] + s[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span>  <span class="number">12</span>  <span class="number">13</span>  <span class="number">14</span>  <span class="number">15</span>  <span class="number">16</span>  <span class="number">17</span>  <span class="number">18</span>  <span class="number">19</span>  <span class="number">20</span>  <span class="number">21</span>  <span class="number">22</span></span><br></pre></td></tr></table></figure><h3 id="二、差分"><a href="#二、差分" class="headerlink" title="二、差分"></a>二、差分</h3><h4 id="5、一维差分"><a href="#5、一维差分" class="headerlink" title="5、一维差分"></a>5、一维差分</h4><p>类似于数学中的求导和积分，差分可以看成前缀和的逆运算。</p><p>差分数组：</p><p>首先给定一个原数组a：a[1], a[2], a[3],,,,,, a[n];</p><p>然后我们构造一个数组b ： b[1], b[2], b[3],,,,,, b[i];</p><p>使得 a[i] &#x3D; b[1] + b[2] + b[3] + ,,,,,, + b[i]</p><p>也就是说，a数组是b数组的前缀和数组，反过来我们把b数组叫做a数组的差分数组。换句话说，每一个a[i]都是b数组中从头开始的一段区间和。</p><p>考虑如何构造差分b数组？</p><p>最为直接的方法</p><p>如下：</p><p>a[0 ]&#x3D; 0;</p><p>b[1] &#x3D; a[1] - a[0];</p><p>b[2] &#x3D; a[2] - a[1];</p><p>b[3] &#x3D; a [3] - a[2];</p><p>……..</p><p>b[n] &#x3D; a[n] - a[n - 1];</p><p>图示:</p><p>我们只要有b数组，通过前缀和运算，就可以在O(n) 的时间内得到 a 数组 。</p><p>知道了差分数组有什么用呢？ 别着急，慢慢往下看。</p><p>话说有这么一个问题：</p><p>给定区间[l, r ]，让我们把a数组中的[l, r] 区间中的每一个数都加上c,即 a[l] + c , a[l + 1] + c , a[l + 2] + c ,,,,,, a[r] + c;</p><p>暴力做法是for循环l到r区间，时间复杂度O(n)，如果我们需要对原数组执行m次这样的操作，时间复杂度就会变成O(n * m)。有没有更高效的做法吗? 考虑差分做法，(差分数组派上用场了)。</p><p>始终要记得，a数组是b数组的前缀和数组，比如对b数组的b[i]的修改，会影响到a数组中从a[i]及往后的每一个数。</p><p>首先让差分b数组中的 b[l] + c ,通过前缀和运算，a数组变成 a[l] + c ,a[l + 1] + c,,,,,, a[n] + c;</p><p>然后我们打个补丁，b[r + 1] - c, 通过前缀和运算，a数组变成 a[r + 1] - c,a[r + 2] - c,,,,,,,a[n] - c;</p><p>为啥还要打个补丁？</p><p>我们画个图理解一下这个公式的由来:</p><p>b[l] + c，效果使得a数组中 a[l] 及以后的数都加上了c(红色部分)，但我们只要求l到r 区间加上 c, 因此还需要执行 b[r + 1] - c,让a数组中 a[r + 1]及往后的区间再减去c(绿色部分)，这样对于a[r] 以后区间的数相当于没有发生改变。</p><p>因此我们得出一维差分结论：给a数组中的[ l, r] 区间中的每一个数都加上c,只需对差分数组b做 b[l] + &#x3D; c, b[r+1] - &#x3D; c 。时间复杂度为O(1), 大大提高了效率。</p><p>总结：</p><p>题目练习： AcWing 797. 差分</p><p>输入一个长度为n的整数序列。<br>接下来输入m个操作，每个操作包含三个整数l, r, c，表示将序列中[l, r]之间的每个数加上c。<br>请你输出进行完所有操作后的序列。</p><p>输入格式<br>第一行包含两个整数n和m。<br>第二行包含n个整数，表示整数序列。<br>接下来m行，每行包含三个整数l，r，c，表示一个操作。<br>输出格式<br>共一行，包含n个整数，表示最终序列。<br>数据范围</p><p>1≤n,m≤100000,<br>1≤l≤r≤n,<br>−1000≤c≤1000,<br>−1000≤整数序列中元素的值≤1000<br>1<br>2<br>3<br>4<br>输入样例：</p><p>6 3<br>1 2 2 1 2 1<br>1 3 1<br>3 5 1<br>1 6 1<br>1<br>2<br>3<br>4<br>5<br>输出样例：</p><p>3 4 5 3 4 2<br>1<br>AC代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N],b[N]; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        b[i] = a[i] - a[i - <span class="number">1</span>];      <span class="comment">//构建差分数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l, r, c;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;c);</span><br><span class="line">        b[l] += c;     <span class="comment">//表示将序列中[l, r]之间的每个数加上c</span></span><br><span class="line">        b[r + <span class="number">1</span>] -= c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        b[i] += b[i - <span class="number">1</span>];  <span class="comment">//求前缀和运算</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span>  <span class="number">12</span>  <span class="number">13</span>  <span class="number">14</span>  <span class="number">15</span>  <span class="number">16</span>  <span class="number">17</span>  <span class="number">18</span>  <span class="number">19</span>  <span class="number">20</span>  <span class="number">21</span>  <span class="number">22</span>  <span class="number">23</span>  <span class="number">24</span>  <span class="number">25</span>  <span class="number">26</span>  <span class="number">27</span></span><br></pre></td></tr></table></figure><h4 id="6、二维差分"><a href="#6、二维差分" class="headerlink" title="6、二维差分"></a>6、二维差分</h4><p>如果扩展到二维，我们需要让二维数组被选中的子矩阵中的每个元素的值加上c,是否也可以达到O(1)的时间复杂度。答案是可以的，考虑二维差分。</p><p>a[][]数组是b[][]数组的前缀和数组，那么b[][]是a[][]的差分数组</p><p>原数组： a[i][j]</p><p>我们去构造差分数组： b[i][j]</p><p>使得a数组中a[i][j]是b数组左上角(1,1)到右下角(i,j)所包围矩形元素的和。</p><p>如何构造b数组呢？</p><p>其实关于差分数组，我们并不用考虑其构造方法，因为我们使用差分操作在对原数组进行修改的过程中，实际上就可以构造出差分数组。</p><p>同一维差分，我们构造二维差分数组目的是为了 让原二维数组a中所选中子矩阵中的每一个元素加上c的操作，可以由O(n*n)的时间复杂度优化成O(1)</p><p>已知原数组a中被选中的子矩阵为 以(x1,y1)为左上角，以(x2,y2)为右下角所围成的矩形区域;</p><p>始终要记得，a数组是b数组的前缀和数组，比如对b数组的b[i][j]的修改，会影响到a数组中从a[i][j]及往后的每一个数。</p><p>假定我们已经构造好了b数组，类比一维差分，我们执行以下操作<br>来使被选中的子矩阵中的每个元素的值加上c</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b[x1][y1] + = c ;</span><br><span class="line"></span><br><span class="line">b[x1,][y2+<span class="number">1</span>] - = c;</span><br><span class="line"></span><br><span class="line">b[x2+<span class="number">1</span>][y1] - = c;</span><br><span class="line"></span><br><span class="line">b[x2+<span class="number">1</span>][y2+<span class="number">1</span>] + = c;</span><br></pre></td></tr></table></figure><p>每次对b数组执行以上操作，等价于：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = x1;i &lt;= x2;i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j = y1;j &lt;= y2;j++)</span><br><span class="line">    a[i][j] += c;</span><br><span class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></span><br></pre></td></tr></table></figure><p>我们画个图去理解一下这个过程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b[x1][y1] += c ; 对应图<span class="number">1</span> ,让整个a数组中蓝色矩形面积的元素都加上了c。</span><br><span class="line">b[x1,][y2 + <span class="number">1</span>] -= c ; 对应图<span class="number">2</span> ,让整个a数组中绿色矩形面积的元素再减去c，使其内元素不发生改变。</span><br><span class="line">b[x2 + <span class="number">1</span>][y1] -= c ; 对应图<span class="number">3</span> ,让整个a数组中紫色矩形面积的元素再减去c，使其内元素不发生改变。</span><br><span class="line">b[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c; 对应图<span class="number">4</span>,让整个a数组中红色矩形面积的元素再加上c，红色内的相当于被减了两次，再加上一次c，才能使其恢复。</span><br></pre></td></tr></table></figure><p>我们将上述操作封装成一个插入函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;     <span class="comment">//对b数组执行插入操作，等价于对a数组中的(x1,y1)到(x2,y2)之间的元素都加上了c</span></span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">    b[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span></span><br></pre></td></tr></table></figure><p>我们可以先假想a数组为空，那么b数组一开始也为空，但是实际上a数组并不为空，因此我们每次让以(i,j)为左上角到以(i,j)为右下角面积内元素(其实就是一个小方格的面积)去插入 c &#x3D; a[i][j] ，等价于原数组a中(i,j) 到(i,j)范围内 加上了 a[i][j] ,因此执行 n*m次插入操作，就成功构建了差分b数组.</p><p>这叫做曲线救国。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m;j++)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="built_in">insert</span>(i, j, i, j, a[i][j]);    <span class="comment">//构建差分数组</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span></span><br></pre></td></tr></table></figure><p>当然关于二维差分操作也有直接的构造方法，公式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b[i][j] = a[i][j] − a[i − <span class="number">1</span>][j] − a[i][j − <span class="number">1</span>] + a[i −<span class="number">1</span> ][j − <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>二维差分数组的构造同一维差分思维相同，因次在这里就不再展开叙述了。</p><p>总结：</p><p>题目练习： AcWing 798. 差分矩阵<br>输入一个n行m列的整数矩阵，再输入q个操作，每个操作包含五个整数x1, y1, x2, y2, c，其中(x1, y1)和(x2, y2)表示一个子矩阵的左上角坐标和右下角坐标。<br>每个操作都要将选中的子矩阵中的每个元素的值加上c。<br>请你将进行完所有操作后的矩阵输出。<br>输入格式<br>第一行包含整数n, m, q。<br>接下来n行，每行包含m个整数，表示整数矩阵。<br>接下来q行，每行包含5个整数x1, y1, x2, y2, c，表示一个操作。<br>输出格式<br>共 n 行，每行 m 个整数，表示所有操作进行完毕后的最终矩阵。<br>数据范围</p><p>1≤n,m≤1000,<br>1≤q≤100000,<br>1≤x1≤x2≤n,<br>1≤y1≤y2≤m,<br>−1000≤c≤1000,<br>−1000≤矩阵内元素的值≤1000<br>1<br>2<br>3<br>4<br>5<br>6<br>输入样例：</p><p>3 4 3<br>1 2 2 1<br>3 2 2 1<br>1 1 1 1<br>1 1 2 2 1<br>1 3 2 3 2<br>3 1 3 4 1<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>输出样例：</p><p>2 3 4 1<br>4 3 4 1<br>2 2 2 2<br>1<br>2<br>3<br>AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N][N], b[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">    b[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">insert</span>(i, j, i, j, a[i][j]);      <span class="comment">//构建差分数组</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x1, y1, x2, y2, c;</span><br><span class="line">        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;</span><br><span class="line">        <span class="built_in">insert</span>(x1, y1, x2, y2, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            b[i][j] += b[i - <span class="number">1</span>][j] + b[i][j - <span class="number">1</span>] - b[i - <span class="number">1</span>][j - <span class="number">1</span>];  <span class="comment">//二维前缀和</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="/2023/04/04/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%A8%A1%E6%9D%BF/"/>
      <url>/2023/04/04/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">10005</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[MAXN];</span><br><span class="line"><span class="type">int</span> Rank[MAXN] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化父节点为自己</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">        Rank[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找祖宗</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? fa[x] : <span class="built_in">Find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并集合</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unite</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = <span class="built_in">Find</span>(x);</span><br><span class="line">    y = <span class="built_in">Find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(x == y) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//深度大的为父节点</span></span><br><span class="line">    <span class="keyword">if</span>(Rank[x] &lt; Rank[y]) fa[x] = y;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        fa[y] = x;</span><br><span class="line">        <span class="keyword">if</span>(Rank[x] == Rank[y]) Rank[x]++;<span class="comment">//当深度相同时,随便哪个都可,当注意深度＋1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例：-年龄种数"><a href="#例：-年龄种数" class="headerlink" title="例： 年龄种数"></a>例： 年龄种数</h3><p><strong>链接：<a href="https://ac.nowcoder.com/acm/contest/53822/B">https://ac.nowcoder.com/acm/contest/53822/B</a></strong></p><p><strong>一个学校中，可能有不同年龄的人生活。tgc 有一天突发奇想想知道这个学校里有多少种年龄存在，但是现在他只知道总人数，那么他只好上街询问，但他又不好当面询问别人的年龄。所以他选择询问两个人，问这两个人的年龄是否相同来得到有多少种年龄的解。最后的数据太多了，你能帮帮他吗</strong></p><h5 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h5><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一行输入一个正整数 t 代表有 t 组数据</span><br><span class="line"></span><br><span class="line">每组数据第一行包含两个用空格隔开的正整数 n 和 m，代表有 n 个人，m 对学生的年龄相同。之后 m 行每行包括两个用空格隔开的正整数 a 和 b，代表年龄相同的是哪两个人（a≠b，且a，b 的组合仅出现一次）。</span><br></pre></td></tr></table></figure><h5 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h5><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每组测试输出一个正整数，代表该学校的年龄种数。</span><br></pre></td></tr></table></figure><h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h4><h5 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">5 3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure><h5 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h5 id="备注"><a href="#备注" class="headerlink" title="备注:"></a>备注:</h5><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 &lt; t ≤ 100</span><br><span class="line">0 &lt; n ≤ 10000</span><br><span class="line">0 &lt; m ≤ n * 2</span><br></pre></td></tr></table></figure><p><strong>实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">10005</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[MAXN];</span><br><span class="line"><span class="type">int</span> Rank[MAXN] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化父节点为自己</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">        Rank[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找祖宗</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? fa[x] : <span class="built_in">Find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并集合</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unite</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = <span class="built_in">Find</span>(x);</span><br><span class="line">    y = <span class="built_in">Find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(x == y) <span class="keyword">return</span>;</span><br><span class="line">    res--;</span><br><span class="line">    <span class="comment">//深度大的为父节点</span></span><br><span class="line">    <span class="keyword">if</span>(Rank[x] &lt; Rank[y]) fa[x] = y;</span><br><span class="line">    <span class="comment">//当深度相同时,随便哪个都可,当注意深度＋1</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        fa[y] = x;</span><br><span class="line">        <span class="keyword">if</span>(Rank[x] == Rank[y]) Rank[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="type">int</span> t, n, m;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="built_in">Init</span>(n);</span><br><span class="line">        res = n;</span><br><span class="line">        <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">            <span class="type">int</span> x, y;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            <span class="built_in">unite</span>(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小表示法</title>
      <link href="/2023/04/04/%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA%E6%B3%95/"/>
      <url>/2023/04/04/%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="最小表示法"><a href="#最小表示法" class="headerlink" title="最小表示法"></a>最小表示法</h3><h4 id="算法解释"><a href="#算法解释" class="headerlink" title="算法解释"></a>算法解释</h4><p>我们这里要i &#x3D; 0,j &#x3D; 1,k &#x3D; 0,表示从i开始k长度和从j开始k长度的字符串相同（i，j表示当前判断的位置）。</p><p>当我们a[i] &#x3D;&#x3D; a[j]时，根据上面k的定义，我们的需要进行k+1操作。</p><p>当a[i]  &gt;a[j]时，我们发现i位置比j位置上字典序要大，那么不能使用i作为开头了，我们要将i向后移动，移动多少呢？有因为i开头和j开头</p><p>的有k个相同的字符，那么就执行 i &#x3D; i + k +1，相反a[i] &lt; a[j]时，执行：j &#x3D; j + k +1 ，最终i和j中较小的值就是我们最终开始的位置。</p><h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_min</span><span class="params">(<span class="type">int</span> a[])</span></span>&#123;</span><br><span class="line">    <span class="comment">//获取循环数组a的最小表示</span></span><br><span class="line"><span class="type">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">2</span>n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>n; i++) b[i] = a[i % n];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>, k;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n &amp;&amp; j &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; n &amp;&amp; b[i + k] == b[j + k]; k++);<span class="comment">//寻找不相同的位置 </span></span><br><span class="line">        <span class="keyword">if</span>(k == n) <span class="keyword">break</span>;<span class="comment">//如果k等于n，那么数组a就由一个相同元素构成 </span></span><br><span class="line">        <span class="keyword">if</span>(b[i + k] &lt; b[j + k])</span><br><span class="line">        &#123;</span><br><span class="line">            j = j + k + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i == j) j++;<span class="comment">//i和j相同时有一个数要+1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b[i + k] &gt; b[j + k])</span><br><span class="line">        &#123;</span><br><span class="line">            i = i + k + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i == j) i++;<span class="comment">//i和j相同时有一个数要+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    k = <span class="built_in">min</span>(i, j);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) a[i] = b[i + k];</span><br><span class="line">&#125; <span class="comment">//get_min</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>枚举</title>
      <link href="/2023/04/04/%E6%9E%9A%E4%B8%BE/"/>
      <url>/2023/04/04/%E6%9E%9A%E4%B8%BE/</url>
      
        <content type="html"><![CDATA[<h3 id="枚举："><a href="#枚举：" class="headerlink" title="枚举："></a><strong>枚举</strong>：</h3><p><strong>基于逐个尝试答案的一种问题求解策略</strong></p><p>例如：求小于 N 的最大素数。枚举法：逐个判断 N-1、N-2、N-3 等是不是素数</p><h3 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h3><h4 id="一、完美立方"><a href="#一、完美立方" class="headerlink" title="一、完美立方"></a>一、完美立方</h4><p><strong>形如 a3&#x3D;b3+c3+d3 的等式被称为完美立方等式。例如 12³&#x3D;6³+8³+10³。编写一个程序，对任给的正整数 N（N&lt;&#x3D;100），寻找所有的四元组（a,b,c,d），使得 a³&#x3D;b³+c³+d³，其中 a,b,c,d 大于 1，小于等于 N，且 b&lt;&#x3D;c&lt;&#x3D;d。</strong></p><h5 id="要求："><a href="#要求：" class="headerlink" title="要求："></a>要求：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：一个正整数N（N&lt;=<span class="number">100</span>）</span><br><span class="line">输出：每行输出一个完美立方。输出格式为：</span><br><span class="line">Cube=a，Triple=(b,c,d)</span><br><span class="line">其中a,b,c,d所在位置分别用实际求出四元组值代入。</span><br><span class="line">请按照a的值，从小到大依次输出。当两个完美立方等式中的a值相同，则b值小的优先输出、仍相同的则c值小的优先输出、再相同则d值小的优先输出。</span><br></pre></td></tr></table></figure><h5 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h5><p>四重循环枚举 a,b,c,d，a 在最外层，d 在最里层，每一层都是从大到小枚举；</p><p>枚举范围 a:[2,N] b:[2,a-1] c:[2,b-1] d:[2,c-1]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d\n&quot;</span>,&amp;N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">2</span>;a&lt;=N;++a)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> b=<span class="number">2</span>;b&lt;a;++b)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> c=<span class="number">2</span>;c&lt;b;++c)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> d=<span class="number">2</span>;d&lt;c;++d)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(a*a*a==b*b*b+c*c*c+d*d*d)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Cube=%d,Triple=(%d,%d,%d)\n&quot;</span>,a,b,c,d);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二、生理周期"><a href="#二、生理周期" class="headerlink" title="二、生理周期"></a>二、生理周期</h4><p><strong>人有体力、情商、智商的高峰日子，它们分别每隔 23 天、28 天和 33 天出现一次。对于每个人，我们想知道何时三个高峰落在同一天。给定三个高峰出现的日子 p,e,i（不一定是第一次高峰出现的日子），再给定另一个指定的日子 d，你的任务是输出日子 d，之后，下次三个高峰落在同一天的日子（用距离 d 表示天数）。例如：给定日子为 10，下次出现三个高峰同一天的日子是 12，则输出 2。</strong></p><p><strong>要求：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">输入四个整数p,e,i,d。p,e,i分别表示体力、情感、智力高峰出现的日子。d是给定的日子，可能小于p,e或i。所有给定日子是非负的并且小于或等于<span class="number">365</span>，所求日子小于或等于<span class="number">21252</span>。</span><br><span class="line">输出：</span><br><span class="line">从给定日子起，下一次三个高峰同一天的日子的天数。</span><br></pre></td></tr></table></figure><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><p>1、从第 d+1 天开始，一直试到第 21252 天，其中每个日期 K，看是否满足。(k-p)%23&#x3D;&#x3D;0&amp;&amp;(k-e)%28&#x3D;&#x3D;0&amp;&amp;(k-i)%33&#x3D;&#x3D;0</p><p>2、先判断 k 是否满足 p，再判断在满足 p 的前提下是否满足 e，再判断是否在满足 p,e 的前提下是否满足 i，再筛选 k 是否小于等于 21252。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 21252</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p,e,i,d,caseNo=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;p&gt;&gt;e&gt;&gt;i&gt;&gt;d&amp;&amp;p!=<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> k;</span><br><span class="line">        ++caseNo;</span><br><span class="line">        <span class="keyword">for</span>(k=d+<span class="number">1</span>;(k-p)%<span class="number">23</span>;++k)</span><br><span class="line">            <span class="keyword">for</span>(;(k-e)%<span class="number">28</span>;K+=<span class="number">23</span>)</span><br><span class="line">                <span class="keyword">for</span>(;(k-i)%<span class="number">33</span>;k+=<span class="number">23</span>*<span class="number">8</span>)</span><br><span class="line">                    cout&lt;&lt;<span class="string">&quot;Case&quot;</span>&lt;&lt;caseNo&lt;&lt;<span class="string">&quot;:the next triple peak occurs in&quot;</span>&lt;&lt;k-d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三、称硬币"><a href="#三、称硬币" class="headerlink" title="三、称硬币"></a>三、称硬币</h4><p><strong>有十二枚硬币。其中有 11 枚真币和 1 枚假币。假币和真币重量不同，但不知道假币比真币重还是轻。现在，用一架天平称了这些币三次，告诉你称的结果，请你找出假币并且确定假币是重还是轻（数据保证一定能找出来）。</strong></p><p><strong>要求：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line"><span class="number">1</span></span><br><span class="line">ABCD   EFGH   even</span><br><span class="line">ABCI     EFJK    up</span><br><span class="line">ABIJ     EFGH   even</span><br><span class="line">输出：</span><br><span class="line">K is the counterfeit coin <span class="keyword">and</span> it is light.</span><br></pre></td></tr></table></figure><h5 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h5><p>先假设 A 是重的假币，代入结果，若符合则 A 为假币且重，否则假设 A 是轻的假币，代入结果，若符合则 A 为假币轻。若都不符合则换 B 进行，以此类推，直至测出假币。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> Left[<span class="number">3</span>][<span class="number">7</span>];</span><br><span class="line"><span class="type">char</span> Right[<span class="number">3</span>][<span class="number">7</span>];</span><br><span class="line"><span class="type">char</span> result[<span class="number">3</span>][<span class="number">7</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsFake</span><span class="params">(<span class="type">char</span> c,<span class="type">bool</span> light)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;                  <span class="comment">//输入测试数据组数</span></span><br><span class="line">    <span class="keyword">while</span>(t--)               <span class="comment">//一组组测试</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            cin &gt;&gt; Left[i] &gt;&gt; Right[i] &gt;&gt; result[i];    <span class="comment">//录入</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c=<span class="string">&#x27;A&#x27;</span>;c&lt;=<span class="string">&#x27;L&#x27;</span>;c++)            <span class="comment">//开始枚举</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">IsFake</span>(c,<span class="literal">true</span>))&#123;</span><br><span class="line">                cout &lt;&lt; c &lt;&lt; <span class="string">&quot;is the counterfeit coin and it is light.\n&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">IsFake</span>(c,<span class="literal">false</span>))&#123;</span><br><span class="line">                cout &lt;&lt; c &lt;&lt; <span class="string">&quot;is the counterfeit coin and it is heavy.\n&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsFake</span><span class="params">(<span class="type">char</span> c,<span class="type">bool</span> light)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i)&#123;</span><br><span class="line">        <span class="type">char</span> *pLeft,*pRight;</span><br><span class="line">        <span class="keyword">if</span>(light)&#123;</span><br><span class="line">            pLeft=Left[i];pRight=Right[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pLeft=Right[i];</span><br><span class="line">            pRight=Left[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span>(result[i][<span class="number">0</span>])&#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>:<span class="keyword">if</span>(<span class="built_in">strchr</span>(pRight,c)==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:<span class="keyword">if</span>(<span class="built_in">strchr</span>(pLeft,c)||<span class="built_in">strchr</span>(pRight,c)) <span class="keyword">return</span> <span class="literal">false</span>;<span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:<span class="keyword">if</span>(<span class="built_in">strche</span>(pLeft,c)==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bool IsFake(char c,bool light)</p><p>bool light，返回值为 true 则假设硬币为轻；false 则假设硬币为重；bool IsFake，返回值为 true 则表示假设成立，否则不成立。</p><p>case ‘u’:if(strchr(pRight,c)&#x3D;&#x3D;NULL) return false;</p><p>判断天平右边是否有假币，若有则返回 false</p><p>case ‘e’:if(strchr(pLeft,c)||strchr(pRight,c)) return false;</p><p>天平是平的，但凡左右两边含假币，都会返回 false。</p><p>case ‘d’:if(strchr(pLeft,c)&#x3D;&#x3D;NULL) return false;</p><p>假币在天平左边，若不在左边，则返回 false。</p><p>声明：switch 语句按照假币为轻编写，若假设假币为重，则将最初的 pLeft,pRight 对调即可。</p><h4 id="四、星星点灯"><a href="#四、星星点灯" class="headerlink" title="四、星星点灯"></a>四、星星点灯</h4><p>有一个由按钮组成的矩阵，其中每行有 6 个按钮，共 5 行。每个按钮的位置上有一盏灯，当按下一个按钮后，该按钮以及周围位置（上下左右）的灯都会改变状态。如果灯原来是点亮的，就会被熄灭，否则被点亮。在矩阵角上的按钮改变 3 盏灯的状态，边上改变 4 盏灯的状态，其它改变 5 盏灯的状态。一个操作会抵消另一种状态。要求怎样按使灯全部熄灭。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">PUZZLE#<span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>解题思路</strong></p><p>第一行确定按的类型后，第二行要使灯熄灭则根据第一行，按钮的方式固定，第三行由第二行按钮的方式固定，第四行由第三行固定，第五行由第四行固定，若第五行按了之后仍不能熄灭，则第一行按的方式错误。改变第一行按的方式，再次测试，直到第五行全部熄灭。</p><p>（即：找出代表全部的局部，然后枚举局部）</p><p>采用位运算，一维 char 类型数组。每组 char 可存 6 个 0 或 1</p><p>枚举第一行，第一行有 2 的五次方，即 64 种状态。利用二进制位，一个二进制位可以表示 0 和 1 两种状态；两个二进制位可以表示 00、01、10、11 四种状态；三个二进制位可以表示 000、001、010、011、100、101、111、110 八种状态；以此类推，六个二进制位可以表示 64 种状态，每种状态对应类似于第一组灯的状态。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> oriLights[<span class="number">5</span>];<span class="comment">//存储灯的矩阵</span></span><br><span class="line"><span class="type">char</span> lights[<span class="number">5</span>];<span class="comment">//变化灯的矩阵</span></span><br><span class="line"><span class="type">char</span> result[<span class="number">5</span>];<span class="comment">//最终结果</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetBit</span><span class="params">(<span class="type">char</span> c,<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (c &gt;&gt; i)&amp;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetBit</span><span class="params">(<span class="type">char</span> &amp;c,<span class="type">int</span> i,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v)&#123;</span><br><span class="line">       c |= (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">       c &amp;= ~(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FlipBit</span><span class="params">(<span class="type">char</span> &amp;c,<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     c ^= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OutputResult</span><span class="params">(<span class="type">int</span> t,<span class="type">char</span> result[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;PUZZLE#&quot;</span> &lt;&lt; t &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">6</span>; j++)&#123;</span><br><span class="line">           cout &lt;&lt; <span class="built_in">GetBit</span>(result[i],j);</span><br><span class="line">           <span class="keyword">if</span>(j &lt; <span class="number">5</span>)</span><br><span class="line">               cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">1</span>; t &lt;= T; ++t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">5</span>;++i)</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">6</span>;++j)&#123;</span><br><span class="line">               <span class="type">int</span> s;</span><br><span class="line">               cin &gt;&gt; s;</span><br><span class="line">               <span class="built_in">SetBit</span>(oriLights[i], j, s);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> n = <span class="number">0</span>; n &lt; <span class="number">64</span>; ++n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> switchs = n;</span><br><span class="line">            <span class="built_in">memcpy</span>(lights,oriLights,<span class="built_in">sizeof</span>(oriLights));</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line">                result[i]=switchs;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">6</span>;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">GetBit</span>(switchs,j))&#123;</span><br><span class="line">                        <span class="keyword">if</span>(j &gt; <span class="number">0</span>) <span class="built_in">FlipBit</span>(lights[i],j<span class="number">-1</span>);</span><br><span class="line">                        <span class="built_in">FlipBit</span>(lights[i],j);</span><br><span class="line">                        <span class="keyword">if</span>(j &lt; <span class="number">5</span>) <span class="built_in">FlipBit</span>(lights[i],j+<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; <span class="number">4</span>)&#123;</span><br><span class="line">                    lights[i+<span class="number">1</span>]^=switchs;</span><br><span class="line">                    switchs=lights[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(lights[<span class="number">4</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">OutputResult</span>(t,result);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性DP</title>
      <link href="/2023/04/04/%E7%BA%BF%E6%80%A7dp/"/>
      <url>/2023/04/04/%E7%BA%BF%E6%80%A7dp/</url>
      
        <content type="html"><![CDATA[<h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><p>具有线性阶段划分的动态规划算法叫作线性动态规划（简称线性DP）。若状态包含多个维度，则每个维度都是线性划分的阶段，也属于线性DP，如下图所示：<br><img src="https://img-blog.csdnimg.cn/9e07a6ff697d48eeb01f71802bb42218.png" alt="在这里插入图片描述"></p><h2 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a>二、题目</h2><h3 id="1-数字三角形"><a href="#1-数字三角形" class="headerlink" title="1.数字三角形"></a>1.数字三角形</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p><img src="https://doc.shiyanlou.com/courses/uid1580206-20210224-1614154063705" alt="图片描述"></p><p>上图给出了一个数字三角形。从三角形的顶部到底部有很多条不同的路径。对于每条路径，把路径上面的数加起来可以得到一个和，你的任务就是找到最大的和。</p><p>路径上的每一步只能从一个数走到下一层和它最近的左边的那个数或者右 边的那个数。此外，向左下走的次数与向右下走的次数相差不能超过 1。</p><h4 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h4><p>输入的第一行包含一个整数 <em>N</em> (1 ≤ <em>N</em> ≤ 100)，表示三角形的行数。</p><p>下面的 <em>N</em> 行给出数字三角形。数字三角形上的数都是 0 至 100 之间的整数。</p><h4 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h4><p>输出一个整数，表示答案。</p><h4 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h4><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><blockquote><p>输入</p></blockquote><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">7</span><br><span class="line">3 8</span><br><span class="line">8 1 0</span><br><span class="line">2 7 4 4</span><br><span class="line">4 5 2 6 5</span><br></pre></td></tr></table></figure><blockquote><p>输出</p></blockquote><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">27</span><br></pre></td></tr></table></figure><h4 id="运行限制"><a href="#运行限制" class="headerlink" title="运行限制"></a>运行限制</h4><ul><li>最大运行时间：1s</li><li>最大运行内存: 256M</li></ul><h5 id="朴素解法"><a href="#朴素解法" class="headerlink" title="朴素解法"></a>朴素解法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">105</span>;</span><br><span class="line"><span class="type">int</span> mat[MAXN][MAXN] = &#123; <span class="number">0</span> &#125;, f[MAXN][MAXN] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            cin &gt;&gt; mat[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>] = mat[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j - <span class="number">1</span>], f[i - <span class="number">1</span>][j]) + mat[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(f[n][(n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>], f[n][(n + <span class="number">2</span>) &gt;&gt; <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="优化后"><a href="#优化后" class="headerlink" title="优化后"></a>优化后</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">105</span>;</span><br><span class="line"><span class="type">int</span> mat[MAXN][MAXN] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">          <span class="type">int</span> t;</span><br><span class="line">          cin &gt;&gt; t;</span><br><span class="line">          mat[i][j] = <span class="built_in">max</span>(mat[i - <span class="number">1</span>][j - <span class="number">1</span>], mat[i - <span class="number">1</span>][j]) + t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(mat[n][(n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>], mat[n][(n + <span class="number">2</span>) &gt;&gt; <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-最大连续子序列"><a href="#2-最大连续子序列" class="headerlink" title="2.最大连续子序列"></a>2.最大连续子序列</h3><p>给定 $K $个整数的序列 ${N_0,N_1,…,N_{(K−1)}}$，其任意连续子序列可表示为 ${N_i,N_{i+1},…,N_j}$，其中 $0≤i≤j&lt;K$。</p><p>最大连续子序列是所有连续子序列中元素和最大的一个，例如给定序列  <code>&#123;−2,11,−4,13,−5,−2&#125;</code> ，其最大连续子序列为 <code>&#123;11,−4,13&#125;</code> ，最大和为 $2020$。</p><p>编写程序得到其中最大子序列的和并输出该子序列的第一个和最后一个元素的下标。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入包含多组测试数据。</p><p>每组数据占 $22$行，第 $11$ 行给出正整数 $K$。</p><p>第 $22$ 行给出 $K$ 个整数 $N_1,…,N_K$。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>每组数据输出一行结果，包含最大子序列的和以及子序列的第一个下标 $i$ 和最后一个元素的下标 $j$。</p><p>所有元素下标为 $0∼K−1$。</p><p>如果最大子序列不唯一，则选择 $i$ 最小的那个子序列，如果仍不唯一，则选择 $i$ 最小的子序列中 $j$ 最小的那个子序列。</p><p>若所有 $K$ 个元素都是负数，则定义其最大和为 $0$，输出 <code>0 0 0</code>。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1≤ K ≤ 105,$<br>$−10000≤Ni≤10000$,<br>输入最多包含 $10$ 组数据。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">6 -2 11 -4 13 -5 -2 10</span><br><span class="line">5</span><br><span class="line">10 -10 10 -10 10</span><br><span class="line">8</span><br><span class="line">-1 -5 -2 3 -1 0 -2 0</span><br><span class="line">4 </span><br><span class="line">-1 -2 -4 -3</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">27 0 7</span><br><span class="line">10 0 0</span><br><span class="line">3 3 3</span><br><span class="line">0 0 0</span><br></pre></td></tr></table></figure><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ul><li>$dp[i$] 为以 $a[i]$ 结尾的最大连续子列和</li><li>遍历序列，若加前一状态子列和能使当前子列和增加则加，即如果前一状态大于等于0，保持当前子序列和递增，若前一状态子序列小于和小于0，则不能是当前子序列增加，则当前子序列的和为自己。</li><li>状态转移方程：<code>dp[i] = max(a[i], dp[i-1]+a[i])(i&gt;=1) ==&gt; dp[i] = a[i] + max(dp[i - 1], 0) </code></li></ul><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[MAXN], f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; k &amp;&amp; k) &#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">-10000</span>, l = <span class="number">1</span>, r = <span class="number">1</span>, le = <span class="number">1</span>;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">            <span class="keyword">if</span>(a[i] &gt;= <span class="number">0</span>) flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(f[i - <span class="number">1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                f[i] = a[i];</span><br><span class="line">                l = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                f[i] = f[i - <span class="number">1</span>] + a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(f[i] &gt; res) &#123;</span><br><span class="line">                res = f[i];</span><br><span class="line">                le = l;</span><br><span class="line">                r = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            cout &lt;&lt; res &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; le - <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; r - <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-最大的和"><a href="#3-最大的和" class="headerlink" title="3.最大的和"></a>3.最大的和</h3><p>对于给定的整数序列 <code>A=&#123;a1,a2,…,an&#125;</code>，找出两个不重合连续子段，使得两子段中所有数字的和最大。</p><p>我们如下定义函数 $d(A)$：$d(A)&#x3D;max_{1≤s1≤t1&lt;s2≤t2≤n}{\sum_{i&#x3D;s1}^{t1} x_i + \sum_{j&#x3D;s2}^{t2} xj}$</p><p>我们的目标就是求出 $d(A)$。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行是一个整数 $T$，代表一共有多少组数据。</p><p>接下来是 $T$ 组数据。</p><p>每组数据的第一行是一个整数，代表数据个数据 $n$，第二行是 $n$ 个整数 $a1,a2,…,an$。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>每组数据输出一个整数，占一行，就是 $d(A)$ 的值。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1≤T≤30,$<br>$2≤n≤50000,$<br>$|ai|≤10000$</p><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">10</span><br><span class="line">1 -1 2 2 3 -3 4 -4 5 -5</span><br></pre></td></tr></table></figure><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">13</span><br></pre></td></tr></table></figure><h4 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h4><p>在样例中，我们取<code>&#123;2,2,3,-3,4&#125;</code>和<code>&#123;5&#125;</code>两个子段，即可得到答案。</p><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>与上面最大连续子序列思路相同，分别求出前后缀最大子序列和，然后枚举求解。</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">50010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> l[MAXN], r[MAXN], w[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T, n;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            cin &gt;&gt;  w[i];</span><br><span class="line">        &#125;</span><br><span class="line">        l[<span class="number">0</span>] = -INF, r[n + <span class="number">1</span>] = -INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, s = -INF; i &lt;= n; i++) &#123;</span><br><span class="line">            s = <span class="built_in">max</span>(<span class="number">0</span>, s) + w[i];</span><br><span class="line">            l[i] = <span class="built_in">max</span>(l[i - <span class="number">1</span>], s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n, s = -INF; i; i--) &#123;</span><br><span class="line">            s = <span class="built_in">max</span>(<span class="number">0</span>, s) + w[i];</span><br><span class="line">            r[i] = <span class="built_in">max</span>(r[i + <span class="number">1</span>], s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = -INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res, l[i] + r[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
